<html lang="en">
<head>
<style>
body {
    width: 1024px;
    font-size: 36px;
    font-family: 'Armata', sans-serif;
    background: url(images/pt-2.png);
    color: #eee;
    text-shadow: 1px 1px 2px #000;
}

.title {
    font-size: 50px;
}

.title2 {
    font-size: 60px;
} 

.subtitle {
    vertical-align: top;
    font-size: 40px;
}

.left {
    text-align: left;
}

/* .code_style { */
/*     text-align: left; */
/*     font-family: "Monospace"; */
/* } */

.step {
    text-align: center;
    width: 1024px;
}

.notes {
    display: none;
}

.hint_text {
    margin-top: 120px;
    font-size: 30px;
    background-color: #282a2f;
    padding: 15px;
    border: 1px solid #484d52;
    border-radius: 5px;
    font-size: 18px;
}

.fallback-message {
    color: #eee;
    line-height: 1.3;
    width: 780px;
    padding: 10px 10px 0;
    margin: 20px auto;
    border: 1px solid #E4C652;
    border-radius: 10px;
}

.fallback-message p {
    margin-bottom: 10px;
}

.impress-supported .fallback-message {
    display: none;
}

em {
    font-style: normal;
    border-bottom: 1px solid #484d52;
    padding-bottom: 2px;
    color: #d5a830;
}
</style>
</head>

<body class="impress-not-supported">
    <div id="impress">
<!-- =================================================================================================== -->
        <div id="title" class="step title" data-x="2600" data-y='-2000'>
            <p>When the mix of modern C++ features surprise you</p>
            <div class="notes">
            <p>- Hello
            <p>- warmup
            <p>- talk about mix of modern c++ features
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="overview" class="step" data-x="2600" data-y='0' data-scale='15'>
            <div class="notes">
            <p>- journey</p>

            I’d like to take you for a journey that I set off couple months ago.
            </div>
        </div>
<!-- =================================================================================================== -->
<!--                                    Chapter I - non Compile                                          -->
<!-- =================================================================================================== -->
        <div id="compile1" class="step" data-x="-1300" data-y="0" data-z="0" style="font-size:45px;">
            <p>auto </p>
            <p>unique_ptr</p>
            <p>move</p>
            <br><br>
            <p>RVO</p>
            <div class=notes>
            <p>- started with mix of auto, smart_ptrs, move semantics</p>
            <p>- ended with compiler RVO: copy elisions and move semantics</p>
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile2" class="step" data-x="-2600" data-y="0" data-z="0">
            <pre><code><p style="text-align: left">
class Combiner { ... };

unique_ptr&ltCombiner> create()
{
    auto combiner = make_unique&ltCombiner>();
    combiner->init();
    ...
    return <strong>move(combiner)</strong>;
}
            </p></code></pre>
            <div class=notes>
            <p>- code review, minor mistake
            <p>- factory fun casting to rval
            <p>- lot of tutorials
            <p>- suffer on performance</p>

            When doing review of code, I noticed a piece of code that contained a minor mistake.
            Factory function, that was creating and initializing a unique pointer, on return was casting it to
            rvalue.
            There’re a lot of tutorials on modern c++ saying that you shouldn’t do that, bc you prevent compiler
            optimization and your code will suffer on performance.
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile3" class="step" data-x="-3900" data-y="0" data-z="0">
            <img src=images/nonCompile/Meyers_return_move.PNG>
            <div class=notes>
            <p>- Meyers, puts in frame, "Effective Modern C++"
            <p>- Briefly - prevents RVO, intro move operation
            <p>- anyway if copy elision not allowed

            It's one of the first things you learn when diving into move semantics,
            Scott Meyers also emphasises it properly in his "Effective Modern C++" book.
            So briefly - it prevents compiler from return value optimization and introduces
            a move operation instead, that would be applied here anyway if copy elision was not allowed.
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile4" class="step" data-x="-2600" data-y="0" data-z="0">
            <div class=notes>
            <p>- In this case RVO inhibited
            <p>- different return types
            <p>- logged a comment, went back to other tasks
            <p>- problem</p>

            In this case - RVO would be inhibited bc function return type and actually returned type
            are different - unique_ptr and rvalue reference to unique_ptr.
            So I logged a comment on that you shouldn’t use move on return from function. I also put there
            few links explaining why, a quote with explanation from Meyers book, and went back to other tasks.
            My collegue noticed comment, fixed code in this place and few other places that were also returning
            move and… told me that there’s a problem.
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile5" class="step" data-x="-3900" data-y="800" data-z="10" style="text-align: left;">
            <pre><code><p>
class MixerInterface{...};
class Mixer : public MixerInterface {...};

unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>Mixer</strong>>();
    mixer->init();
    ...
    return <strong>move(mixer)</strong>;
}
            </p></code></pre>
            <div class=notes>
            <p>- almost the same
            <p>- also unique_ptrs
            <p>- only difference - auto
            <p>- returnes derived class</p>
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile6" class="step" data-x="-3900" data-y="1600" data-z="20">
            <pre><code><p style="text-align: left; font-size:30;">
unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>Mixer</strong>>();
    mixer->init();
    ...
    return <strong>mixer</strong>;
}



error: cannot bind 'unique_ptr&ltMixer>' lvalue
                to 'unique_ptr&ltMixer>&&'
            </p></code></pre>
        <div class=notes>
        <p>- compiler error
        <p>- no RVO but move ctor (fine)
        <p>- why lvalue error?</p>

        How surprised were we, when it turned out that this function produced compiler error.
        And it was kind of not obvious in the beginning - obviously no RVO happened cause compiler tried
        to fire move ctor for unique_ptr (this is fine bc)
        type of fun prototype and returned object are different), but had only lvalue available.
        Why is there lvalue error?
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile7" class="step" data-x="-3900" data-y="2400" data-z="0">
            <pre><code><p style="text-align:left; font-size:28;">
note: initializing argument 1 of
'unique_ptr<_Tp, _Dp>::unique_ptr(unique_ptr<_Up, _Ep>&&)
[with _Up = Mixer;          _Ep = default_delete<Mixer>;
      _Tp = MixerInterface; _Dp = default_delete<MixerInterface>]'



unique_ptr&lt<strong>MixerInterface</strong>>::unique_ptr(unique_ptr&lt<strong>Mixer</strong>>&& u);



unique_ptr&ltMixerInterface>(mixer);
            </p></code></pre>
        <div class=notes>
        <p>- why not copy ctor
        <p>- converting move ctor</p>

        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile7b" class="step" data-x="-3900" data-y="1600" data-z="0">
        <div class=notes>
        <p>- can't bind lval to rval ref</p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile8" class="step" data-x="-2600" data-y="2400" data-z="0">
            <pre><code><p style="text-align:left; font-size:30;">
unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    return make_unique&lt<strong>Mixer</strong>>();
    // OK - move ctor
}



unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    unique_ptr&lt<strong>MixerInterface</strong>> mixer = make_unique&lt<strong>Mixer</strong>>();
    mixer->init();
    ...
    return mixer;
    // OK - NRVO
}
            </p></code></pre>
        <div class=notes>
        <p>- debugging - compiles
        <p>- return rvalue object directly
        <p>- returns lvalue object of type MixerInterface - NRVO
        </p>
        We started debugging to see what's going on, and checked that these 2 pieces of code are compiled fine.
        </div>
        </div>

<!-- =============================================================================================================== -->
        <div id="compile9" class="step" data-x="-2600" data-y="1600" data-z="0">
            <pre><code><p style="text-align:left; font-size:25;">
unique_ptr&lt<strong>const MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>MixerInterface</strong>>();
    mixer->init();
    ...
    return mixer;
}


error: cannot bind 'unique_ptr&ltMixerInterface>' lvalue
                to 'unique_ptr&ltMixerInterface>&&'


unique_ptr&lt<strong>const MixerInterface</strong>>::unique_ptr(unique_ptr&lt<strong>MixerInterface</strong>>&& u);
            </p></code></pre>
        <div class=notes>
        <p>- further analysis
        <p>- return base class type with const base class prototype
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile10" class="step" data-x="-2600" data-y="800" data-z="0">
            <pre><code><p style="text-align:left; font-size:35;">
<strong>MixerInterface</strong> create()
{
    return <strong>Mixer()</strong>;
    // OK - move ctor
}


<strong>MixerInterface</strong> create()
{
    <strong>Mixer</strong> x;
    return x;
    // OK - copy ctor
}
            </p></code></pre>
        <div class=notes>
        <p>- further testing
        <p>- rval, move ctor, as expected
        <p>- lval, ok but why not NRVO?</p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile11" class="step" data-x="-1300" data-y="800" data-z="0">
            <p>c++11
            <p>gcc 4.9.2
            <p>gcc up to 4.9.4
            <p>www.godbolt.org
        <div class=notes>
        <p>-
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile12" class="step" data-x="-1300" data-y="1600" data-z="0">
            gcc 5.1+
            <pre><code><p style="text-align:left; font-size:20;">
unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>Mixer</strong>>();
    return <strong>mixer</strong>;
    // OK - move ctor
}

unique_ptr&ltMixerInterface>::unique_ptr&ltMixer>(unique_ptr&ltMixer>&& u)



unique_ptr&lt<strong>const MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>MixerInterface</strong>>();
    return mixer;
    // OK - move ctor
}

unique_ptr&ltMixerInterface const>::unique_ptr&ltMixerInterface>(unique_ptr&ltMixerInterface>&& u)

            </p></code></pre>
        <div class=notes>
        <p>- compiler 5.1 - ok
        <p>- move ctor - as expected
        <p>- we assumed that it's a compiler error
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile13" class="step" data-x="-1300" data-y="2400" data-z="0">
            gcc 8.1+
            <pre><code><p style="text-align:left; font-size:30;">
MixerInterface create()
{
    Mixer x;
    return x;
    // OK - move ctor now!
}
            </p></code></pre>
            <img src=images/nonCompile/create_gcc.png>
        <div class=notes>
        <p>- newer compiler
        <p>- still compiles but now move ctor instead of copy ctor
        </p>
        </div>
        </div>
        <div id="compile14" class="step" data-x="-1300" data-y="3200" data-z="0">
            latest clang 8.0.0
            <pre><code><p style="text-align:left; font-size:30;">
MixerInterface create()
{
    Mixer x;
    return x;
    // OK - still copy ctor
}
            </p></code></pre>
            <img src=images/nonCompile/create_clang.png>
        <div class=notes>
        <p>- on clang still copy ctor
        </p>
        </div>
        </div>
        <div id="compile15" class="step" data-x="-2600" data-y="3200" data-z="0">
        <p style="font-size:60;">Summary:</p>
        <p>unique_ptr to class hierarchy doesn't compile on gcc 4.9.4-
        <p>it compiles on gcc 5.1+
        <p>class hierarchy performs copy on gcc 8.0-
        <p>class hierarchy performs move on gcc 8.1+
        <p>class hierarchy performs copy on clang 8.0.0
        <p><br><strong>Pretty messed up</strong></p>
        </div>
<!--        <div class="step" data-x="-3900" data-y="3200" data-z="0">
            asdasda</div>
        <div class="step" data-x="-3900" data-y="4000" data-z="0">
            asdasda</div>
        <div class="step" data-x="-2600" data-y="4000" data-z="0">
            asdasda</div>
        <div class="step" data-x="-1300" data-y="4000" data-z="0">
            asdasda</div>
        <div class="step" data-x="-5200" data-y="0" data-z="0">asdasda</div>
        <div class="step" data-x="-5200" data-y="800" data-z="0">
            asdasda</div>
        <div class="step" data-x="-5200" data-y="1600" data-z="0">
            asdasda</div>
        <div class="step" data-x="-5200" data-y="2400" data-z="0">
            asdasda</div>
        <div class="step" data-x="-5200" data-y="3200" data-z="0">
            asdasda</div>
        <div class="step" data-x="-5200" data-y="4000" data-z="0">
            asdasda</div> -->
<!-- =================================================================================================== -->
<!--                                    Chapter II - Copy elision                                        -->
<!-- =================================================================================================== -->
        <div id="copyElision1" class="step" data-x="1300" data-y="0" data-z="0">
        <p class=title2>Copy elision</p>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision2" class="step" style="text-align:left;" data-x="2600" data-y="0" data-z="0">
        <p>- mechanism that is permitted under certain conditions
        <p>- allowed, not required
        <p>- omit copy/move ctors
        <p>- even if ctor/dtor have side efects
        <p>- objects constructed directly in the storage they'd be copied to
        <p>- copy/move ctors need to be present anyway
        <p>- debug mode
        </p>
        </div>
        <div class=notes>
        <p>-
        </p>
        Ok so let's structurize our knowledge a litte and go briefly from the beginnig. What is copy elision?
        It's a mechanism that under certain conditions allows compiler, but not requires to, to omit copy and move constructors, even if the copy/move constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to.
        This is an optimization: even when it takes place and the copy/move constructor is not called, it still must be present and accessible.
        Because some compilers do not perform copy elision in every situation where it is allowed (e.g., in debug mode), programs that rely on the side-effects of copy/move constructors and destructors are not portable.

        </div>
<!-- =================================================================================================== -->
        <div id="copyElision3" class="step" data-x="3900" data-y="0" data-z="0">
        <p>C++ standard wording</p>
        <img src=images/copyElision/copy_elision_standard_cpp14.PNG>
        <div class=notes>
        <p>- see wording
        <p>- a lot of text and there's a reason
        <p>- compiler allowed but not obligated to elide
        <p>- 4 situations
        <p>- on fun return, var is local, purpose of life is to be copied, types the same
        <p>- for throw statement
        <p>- init with temporary (also the same type)
        <p>- for exception handler
        <p>- quote from cpp14, cpp17 just little reworded
        </p>
        Let's see whats wording of standard for this. Actually there're a lot of text and there's a reason for this,
        but we can just focus on highlited part. It says that compiler is allowed but now obligated to elide copies and
        there're 4 specific situations where it can be done. On function return, where the variable to be copied 
        is a local, it's only purpose of life is to be copied to caller function and it's type is the same as type in
        function prototype.
        Then there's case for copy elision in throw statement, then for object initialization with a temporary object
        which also need to be of the same type as object being initialized and in the end there's copy elision for
        exception handler. We're going to consider these two mainly.
        This is quote from cpp14, cpp17 is just a little reworded.
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="copyElision4" class="step" data-x="3900" data-y="800" data-z="10">
        <p class="title2">Copy elision - extracted<br><br></p>
        <p>- automatic storage
        <p>- the same type
        <p>- results "as if" copies were made
        <div class=notes>
        <p>-
        </p>
        </div>
        </div>      
<!-- =================================================================================================== -->            
        <div id="copyElision5" class="step" data-x="3900" data-y="1600" data-z="20">
        <p class=title>RVO, NRVO</p>
        
            <pre><code><p style="text-align: left">
            <img style="float:right;" src=images/copyElision/copy_elision_fun1.PNG>
Mixer fun1() {
    ...
    return Mixer{};
    // RVO
}
            <img style="float:right;" src=images/copyElision/copy_elision_fun2.PNG>
Mixer fun2() {
    Mixer x;
    ...
    return x;
    // NRVO
}
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision6" class="step" data-x="3900" data-y="2400" data-z="300">
        <p class=title>init objects with temporary</p>
            <pre><code><p style="text-align: left;">
            <img style="float:right;" src=images/copyElision/copy_elision_fun3.PNG>
void fun3(Mixer x) {...}

int main() {
    // create arg with temp object
    fun3(Mixer({});
}

    
            
// create var with temp object <img style="float:right;" src=images/copyElision/copy_elision_x1.PNG>
Mixer x1 = Mixer{};
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision7" class="step" data-x="2600" data-y="2400" data-z="0">
        <p class=title>copy elision combined</p>
            <pre><code><p style="text-align: left">
// RVO + create var with temp object
Mixer x2 = fun1(); <img style="float:right;" src=images/copyElision/copy_elision_x2.PNG>



// RVO + create arg with temp object
fun3(fun1());   <img style="float:right;" src=images/copyElision/copy_elision_fun3_fun1.PNG>
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision8" class="step" data-x="2600" data-y="1600" data-z="0">
        <p class=title>Copy elision for exceptions</p>
            <img style="float:right;" src=images/copyElision/copy_elision_fun4.PNG>     
            <pre><code><p style="text-align: left">
void fun4() {
    // copy-elision in
    // throw-expression
    throw Mixer{};
}
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision9" class="step" data-x="2600" data-y="800" data-z="0">
            <img style="float:right;" src=images/copyElision/copy_elision_fun5.PNG>
            <pre><code><p style="text-align: left">
void fun5() {
    // copy-elision in
    // throw-expression
    // no?
    Mixer x;
    throw x;
}
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision10" class="step" data-x="1300" data-y="800" data-z="0">
            <img style="float:right;" src=images/copyElision/copy_elision_fun6.PNG>
            <pre><code><p style="text-align: left">
void fun6() {
    try {
        fun5();
    }
    catch (Mixer x) {
        // copy-elision in
        // exception-handler
        // no?
        // no move ctor - fine
    }
}
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision11" class="step" data-x="1300" data-y="1600" data-z="0">
        <p class=title>Branching</p>
            <pre><code><p style="text-align: left">
// no RVO
Mixer create1(int q) {
    Mixer x1, x2;
    if(q > 4)
        return x1;
    else
        return x2;
}
            </p></code></pre>
        <div class=notes>
        <p>- no RVO cause needs to know which object to put into caler storage
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision12" class="step" data-x="1300" data-y="2400" data-z="0">
            <pre><code><p style="text-align: left">
// optimized for RVO
Mixer create2(int q) { 
    if(q > 4) {
        Mixer x1, x2;
        return x1;
    }
    else {
        Mixer x1, x2;
        return x2;
    }
}
            </p></code></pre>
        <div class=notes>
        <p>- wise compiler can optimise to this - RVO
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision13" class="step" data-x="1300" data-y="3200" data-z="0">
            <pre><code><p style="text-align: left">
bool pred(Mixer& x1, Mixer& x2)
{
    return x1 > x2;
}


// no RVO possible
Mixer create3(int q) {
    Mixer x1, x2;
    if(pred(x1,x2))
        return x1;
    else
        return x2;
}           </p></code></pre>
        <p>Never depend on side effects in move/copy ctor, as small change in code can allow or inhibit RVO.</p>
        <div class=notes>
        <p>- no RVO cause both objects need to be created before decision which should be returned
        <p>- never depend on side effects from copy/move ctors
        <p>- small change may allow or inhibit RVO
        </p>
        </div>          
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision14" class="step" data-x="2600" data-y="3200" data-z="0">
        <p class=title>What's magic behind copy elision</p>
        <pre class=left><code>
Mixer fun() {
    int z;
    Mixer x;
    return x;
}

Mixer y{fun()};
        </code></pre>
        <p>How many params fun() takes?
        <div class=notes>
        <p>- mechanics behind c.e.
        </p>

        </div>    
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision15" class="step" data-x="3900" data-y="3200" data-z="0">
        <p>0 params</p>
        <p>?</p>
        <p>1 param</p>

        <div class=notes>
        <p>- 
        </p>

        </div>
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision16" class="step" data-x="3900" data-y="4000" data-z="0">
        <img src=images/copyElision/fun_stack1.PNG>
        <p><br>1 param
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision17" class="step" data-x="2600" data-y="4000" data-z="0">
        <img src=images/copyElision/fun_stack2.PNG>
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision18" class="step" data-x="1300" data-y="4000" data-z="0">
        <img style="float:right" src=images/copyElision/fun_stack3.PNG>
        <pre class=left><code>
Mixer fun() {
    int z;
    Mixer x;
    return x;
}

Mixer y{fun()};
        </code></pre>
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision19" class="step" data-x="5200" data-y="0" data-z="0">
        <img style="float:right" src=images/copyElision/fun_stack4.PNG>
        <pre class=left><code>
Mixer fun() {
    int z;
    Mixer x;
    return x;
}

Mixer y{fun()};
        </code></pre>
        </div>
<!-- =================================================================================================== -->        
        <div id="copyElision20" class="step" data-x="5200" data-y="800" data-z="0">
        <img style="float:right" src=images/copyElision/fun_stack5.PNG>
        <pre class=left><code>
Mixer fun() {
    int z;
    Mixer x;
    return x;
}

Mixer y{fun()};
        </code></pre>
        </div>
<!-- =================================================================================================== -->        
        <div id="copyElision21" class="step" data-x="5200" data-y="1600" data-z="0">
        <p class=title>RVO in C++17</p>
        <pre><code><p style="text-align: left">
struct Factory {
  Factory(){};
  Factory(const Factory &) = delete;
  Factory(Factory &&) = delete;
};

Factory getFactory() { return Factory{}; }
    
<strong>error</strong>: use of deleted function
       'Factory::Factory(Factory&&)'
        </p>
        </code>
        </pre>
        <div class=notes>
        <p>- c11, c14 main problem - can't get rid of copy/move ctor
        <p>- copy elision might not take place
        <p>- prevents non-movable types from
        <p>- such as factories
        </p>
        In C++11 and C++14 the main problem is that, without guaranteed elision, you cannot get rid of the move and copy constructor,
        because elision might not take place. This prevents non-movable types from having functions that return by value,
        such as factories.
        </div>    
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision22" class="step" data-x="5200" data-y="2400" data-z="0">
        <p class=title>"Guaranteed copy elision through simplified value categories"</p>
        <br>
        <p class=left>- prvalue - initializer of object</p>
        <p class=left>- glvalue - location of object</p>
        <p class=left>- value returned from function, when init with temporary, is init directly
        <p class=left>- no copy/move ctor needed
        <div class=notes>
        <p>- name of proposal
        <p>- distinguish between prvalue and temp objects initialized by them
        <p>- g/p defined as ...
        <p>- prvalue initializes object directly
        <p>- as a consequence, init ...
        <p>- no copy, no move
        <p>- move/copy ctors not needed
        </p>
        The complete name of the proposal is ...
        To achieve guaranteed copy elision, the proposal suggest distinguishing between prvalue (pure rvalue) expressions
        and the temporary objects initialized by them. More specifically, a glvalue (generalized lvalue) is defined
        as the location of an object and a prvalue is defined as the initializer of the object.
        If a prvalue is used as the initializer of an object with the same type, it initializes it directly.
        As a consequence, initializing the return value of a function with a temporary causes the value to be initialized directly,
        without a copy or a move. This means that the copy or move constructor of the object no longer needs to be accessible.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision23" class="step" data-x="5200" data-y="3200" data-z="0">
        <p class=title>Actually...</p>
        <p class=left>- it's not copy elision anymore
        <p class=left>- no copy to elide
        <p class=left><strong>- deferred temporary materialization</strong></p>
            
        </div>
<!-- =================================================================================================== -->
<!--                                    Chapter II - Move                                         -->
<!-- =================================================================================================== -->
        <div class="step" data-x="7800" data-y="0" data-z="0">asdasda</div>

        <div class="step" data-x="9100" data-y="0" data-z="0">
            <!-- <img src=images/a.jpeg> -->
            asdasda
        </div>

        <div class="step" data-x="10400" data-y="0" data-z="0">asdasda</div>
        <div class="step" data-x="10400" data-y="800" data-z="10">
            asdasda</div>
        <div class="step" data-x="10400" data-y="1600" data-z="20">
            asdasda</div>
        <div class="step" data-x="10400" data-y="2400" data-z="300">
            asdasda</div>
        <div class="step" data-x="9100" data-y="2400" data-z="0">
            asdasda</div>
        <div class="step" data-x="9100" data-y="1600" data-z="0">
            asdasda</div>
        <div class="step" data-x="9100" data-y="800" data-z="0">asdasda
        </div>
        <div class="step" data-x="7800" data-y="800" data-z="0">asdasda
        </div>
        <div class="step" data-x="7800" data-y="1600" data-z="0">
            asdasda</div>
        <div class="step" data-x="7800" data-y="2400" data-z="0">
            asdasda</div>
        <div class="step" data-x="7800" data-y="3200" data-z="0">
            asdasda</div>
        <div class="step" data-x="9100" data-y="3200" data-z="0">
            asdasda</div>
        <div class="step" data-x="10400" data-y="3200" data-z="0">
            asdasda</div>
        <div class="step" data-x="10400" data-y="4000" data-z="0">
            asdasda</div>
        <div class="step" data-x="9100" data-y="4000" data-z="0">
            asdasda</div>
        <div class="step" data-x="7800" data-y="4000" data-z="0">
            asdasda</div>
        <div class="step" data-x="11700" data-y="0" data-z="0">asdasda</div>
        <div class="step" data-x="11700" data-y="800" data-z="0">
            asdasda</div>
        <div class="step" data-x="11700" data-y="1600" data-z="0">
            asdasda</div>
        <div class="step" data-x="11700" data-y="2400" data-z="0">
            asdasda</div>
        <div class="step" data-x="11700" data-y="3200" data-z="0">
            asdasda</div>
        <div class="step" data-x="11700" data-y="4000" data-z="0">
            asdasda</div>
        <!--
            <div id="slide2" class="step" data-x="1200" "data-y="0" data-z="0">
                <p>This Slide Moves From Right To Left</p>
            </div>

            <div id="slide3" class="step" data-x="2200" data-y="500">
                <p>This Slide Moves From Right To Left and Bottom To Top</p>
            </div>

            <div id="slide4" class="step" data-x="2200" data-y="-500">
                <p>This Slide Moves Top To Bottom</p>
            </div>

            <div id="slide5" class="step" data-x="3200" data-rotate="150">
                <p>This Slide Rotates Clockwise Around z-axis</p>
            </div>

            <div id="slide6" class="step" data-x="6200" data-scale='3'>
                <p>This Slide Scales 3 Times</p>
            </div>

            <div id="slide7" class="step" data-x="4200" data-y='1500' data-z='1500'>
                <p>Away</p>
            </div>

            <div id="slide8" class="step" data-x="4900" data-y='1500' data-z='100'>
                <p>Towards</p>
            </div>

            <div id="slide9" class="step" data-x="5600" data-y='1500' data-z='-1500'>
                <p>Futher Towards</p>
            </div>
 -->
        <!--
            <div id="slide10" class="step" data-x="2600" data-y='3000' data-scale='15'>
                <p>Visualization Slide Positions</p>
            </div>
 -->

    </div>

    <div class="fallback-message">
        <p>
            Your browser <b>doesn't support the features required</b> by
            impress.js, so you are presented with a simplified version of this
            presentation.
        </p>
        <p>
            For the best experience please use the latest <b>Chrome</b>, <b>Safari</b>
            or <b>Firefox</b> browser.
        </p>
    </div>

    <script type="text/javascript" src="js/impress.js"></script>
    <script type="text/javascript">impress().init();</script>
</body>
</html>


