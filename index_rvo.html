<html lang="en">
<head>
<style>
body {
    width: 1024px;
    font-size: 36px;
    font-family: 'Armata', sans-serif;
    background: url(images/pt-2.png);
    color: #eee;
    text-shadow: 1px 1px 2px #000;
}

#table_style {
  font-family: 'Armata', sans-serif;
  font-size:30px;
  border-collapse: collapse;
  width: 100%;
}

a {
    color:white;
}

.title {
    font-size: 50px;
}

.title2 {
    font-size: 60px;
} 

.subtitle {
    vertical-align: top;
    font-size: 40px;
}

.left {
    text-align: left;
}

.link {
    font-size:25;
}

.step {
    text-align: center;
    width: 1014px;
/*     margin: 0px 20px; */
     margin-left:10px;
     margin-right:10px;
}

.notes {
    display: none;
}

/* hide non-active slides */
.impress-enabled .step {
opacity: 0.01;
}

/* only show active slide */
.impress-enabled .step.active { opacity: 1;}

/* for slides using other slides */
.impress-on-overview .step    { opacity: 1;}
.impress-on-compile4 #compile2    { opacity: 1;}
.impress-on-compile7b #compile6    { opacity: 1;}

/* for darkening slides during transition */
.impress-enabled .step {
   -webkit-transition: opacity 1s;
   -moz-transition:    opacity 1s;
   -ms-transition:     opacity 1s;
   -o-transition:      opacity 1s;
   transition:         opacity 1s;
}

.hint_text {
    margin-top: 120px;
    font-size: 30px;
    background-color: #282a2f;
    padding: 15px;
    border: 1px solid #484d52;
    border-radius: 5px;
    font-size: 18px;
}

.fallback-message {
    color: #eee;
    line-height: 1.3;
    width: 780px;
    padding: 10px 10px 0;
    margin: 20px auto;
    border: 1px solid #E4C652;
    border-radius: 10px;
}

.fallback-message p {
    margin-bottom: 10px;
}

.impress-supported .fallback-message {
    display: none;
}

em {
    font-style: normal;
    border-bottom: 1px solid #484d52;
    padding-bottom: 2px;
    color: #d5a830;
}
</style>
</head>

<body class="impress-not-supported">
    <div id="impress">
<!-- =================================================================================================== -->
        <div id="title" class="step title" data-x="2600" data-y='-1500'>
            <p>When the mix of modern C++ features surprise you</p>
            <div class="notes">
            <p>- Hello
            <p>- warmup
            <p>- talk about mix of modern c++ features
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="overview" class="step" data-x="3500" data-y='-1500' data-scale='16'>
            <div class="notes">
            <p>- journey</p>

            I’d like to take you for a journey that I set off couple months ago.
            </div>
        </div>
<!-- =================================================================================================== -->
<!--                                    Chapter I - non Compile                                          -->
<!-- =================================================================================================== -->
        <div id="compile1" class="step" data-x="-1300" data-y="0" data-z="0" style="font-size:45px;">
            <p>auto </p>
            <p>unique_ptr</p>
            <p>move</p>
            <br><br>
            <p>RVO</p>
            <div class=notes>
            <p>- started with mix of auto, smart_ptrs, move semantics</p>
            <p>- ended with compiler RVO: copy elision and move semantics</p>
            </div>
        </div>
        <div id="compile1b" class="step" data-x="-1300" data-y="-800" data-z="-1000" style="font-size:45px;">
            <p class=title>Copy elision recall</p>
            <pre><code><p style="text-align:left; font-size:30;">
auto fun1()
{
    return std::vector<int>(100);
    // RVO (Return Value Optimization)
}

auto fun2()
{
    std::vector<int> vec(100);
    return vec;
    // Named RVO
}

auto vec = fun1();   // only one ctor call - copy elided
auto vec = fun2();   // only one ctor call - copy elided
            </p></code></pre>
            <div class=notes>
            <p> - copy elision recall
            <p> - ctor called only onec
            <p> - even though language rules say that there will be a copy
            <p> - compiler optimization
            </div>
        </div>
        <div id="compile1c" class="step" data-x="-1300" data-y="-800" data-z="-2000" style="font-size:45px;">
            <p class=title>Move semantics recall</p>
            <pre><code><p style="text-align:left; font-size:30;">
std::vector<int> vec(100);

auto vec_copy = vec;
auto vec_move = std::move(vec);




vector::vector(const T&) - <b>copy</b> ctor overload resolution for lvalues
vector::vector(T&&)      - <b>move</b> ctor overload resolution for rvalues


std::move - only casts to rvalue reference
            </p></code></pre>
            <div class=notes>
            <p> - move semantics recall
            <p> - new object created - by copy and by move
            <p> - move usually steals memory oh heap
            <p> - leaves object in unspecified but valid state
            <p> - ctor overload resolution decides how new object is created
            <p> - std::move - no move but cast
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile2" class="step" data-x="-2600" data-y="0" data-z="0">
        <p class=title>Back to story</p>
            <pre><code><p style="text-align: left">
class Combiner { ... };

unique_ptr&ltCombiner> create()
{
    auto combiner = make_unique&ltCombiner>();
    combiner->init();
    ...
    return <strong>move(combiner)</strong>;
}
            </p></code></pre>
            <div class=notes>
            <p>- code review, minor mistake
            <p>- factory fun casting to rval
            <p>- lot of tutorials
            <p>- suffer on performance</p>

            When doing review of code, I noticed a piece of code that contained a minor mistake.
            Factory function, that was creating and initializing a unique pointer, on return was casting it to
            rvalue.
            There’re a lot of tutorials on modern c++ saying that you shouldn’t do that, bc you prevent compiler
            optimization and your code will suffer on performance.
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile3" class="step" data-x="-3900" data-y="0" data-z="0">
            <img src=images/nonCompile/Meyers_return_move.PNG>
            <div class=notes>
            <p>- Meyers, puts in frame, "Effective Modern C++"
            <p>- Briefly - prevents RVO, intro move operation
            <p>- anyway if copy elision not allowed
            </p>
            It's one of the first things you learn when diving into move semantics,
            Scott Meyers also emphasises it properly in his "Effective Modern C++" book.
            So briefly - it prevents compiler from return value optimization and introduces
            a move operation instead, that would be applied here anyway if copy elision was not allowed.
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile4" class="step" data-x="-2600" data-y="0" data-z="0">
            <div class=notes>
            <p>- In this case c.e. inhibited
            <p>- different return types
            <p>- logged a comment, went back to other tasks
            <p>- collegue fixed here and few other places
            <p>- problem</p>

            In this case - c.e. would be inhibited bc function return type and actually returned type
            are different - unique_ptr and rvalue reference to unique_ptr.
            So I logged a comment on that you shouldn’t use move on return from function. I also put there
            few links explaining why, a quote with explanation from Meyers book, and went back to other tasks.
            My collegue noticed comment, fixed code in this place and few other places that were also returning
            move and… told me that there’s a problem.
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile5" class="step" data-x="-3900" data-y="800" data-z="10" style="text-align: left;">
            <pre><code><p>
class MixerInterface{...};
class Mixer : public MixerInterface {...};

unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>Mixer</strong>>();
    mixer->init();
    ...
    return <strong>move(mixer)</strong>;
}
            </p></code></pre>
            <div class=notes>
            <p>- almost the same, only class hierarchy
            <p>- also unique_ptrs
            <p>- only difference - auto deduces different type
            <p>- returnes derived class</p>
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile6" class="step" data-x="-3900" data-y="1600" data-z="0">
            <pre><code><p style="text-align: left; font-size:30;">
unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>Mixer</strong>>();
    mixer->init();
    ...
    return <strong>mixer</strong>;
}



error: cannot bind 'unique_ptr&ltMixer>' lvalue
                to 'unique_ptr&ltMixer>&&'
            </p></code></pre>
        <div class=notes>
        <p>- compiler error - can't bind lvalue to rvalue ref
        <p>- obviously no c.e. but move ctor (fine cause different type)
        <p>- why lvalue error?
        <p>- not a rocket science code
        </p>

        How surprised were we, when it turned out that this function produced compiler error.
        And it was kind of not obvious in the beginning - obviously no c.e. happened cause compiler tried
        to fire move ctor for unique_ptr (types are different), but had only lvalue available.
        Why is there lvalue error?
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile7" class="step" data-x="-3900" data-y="2400" data-z="0">
            <pre><code><p style="text-align:left; font-size:28;">
note: initializing argument 1 of
'unique_ptr<_Tp, _Dp>::unique_ptr(unique_ptr<_Up, _Ep>&&)
[with _Up = Mixer;          _Ep = default_delete<Mixer>;
      _Tp = MixerInterface; _Dp = default_delete<MixerInterface>]'




unique_ptr&lt<strong>MixerInterface</strong>>::unique_ptr(unique_ptr&lt<strong>Mixer</strong>>&& u);
            </p></code></pre>
        <div class=notes>
        <p>- converting move ctor
        <br>on type of base class
        <br>with param type of derived class
        <br>mix of auto unique_ptr and hierarchy is broken</p>

        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile7b" class="step" data-x="-3900" data-y="1600" data-z="0">
        <div class=notes>
        <p>- can't bind lval to rval ref</p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile8" class="step" data-x="-2600" data-y="2400" data-z="0">
            <p class=title>So debugging starts...</p>
            <pre><code><p style="text-align:left; font-size:30;">unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    return make_unique&lt<strong>Mixer</strong>>();
    // OK - move ctor
}


unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    unique_ptr&lt<strong>MixerInterface</strong>> mixer = make_unique&lt<strong>Mixer</strong>>();
    return mixer;
    // OK - NRVO
}
            </p></code></pre>
        <div class=notes>
        <p>- debugging - check if compiles
        <p>- return pure rvalue object directly, with move op
        <p>- returns lvalue object of type MixerInterface - NRVO
        </p>
        We started debugging to see what's going on, and checked that these 2 pieces of code are compiled fine.
        </div>
        </div>

<!-- =============================================================================================================== -->
        <div id="compile9" class="step" data-x="-2600" data-y="1600" data-z="0">
        <p class=title>Another compilation error</p>
            <pre><code><p style="text-align:left; font-size:30;">
unique_ptr&lt<strong>const MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>MixerInterface</strong>>();
    mixer->init();
    ...
    return mixer;
}


error: cannot bind 'unique_ptr&ltMixerInterface>' lvalue
                to 'unique_ptr&ltMixerInterface>&&'


unique_ptr&lt<strong>const MixerInterface</strong>>::
unique_ptr(unique_ptr&lt<strong>MixerInterface</strong>>&& u);
            </p></code></pre>
        <div class=notes>
        <p>- we found another error
        <p>- return base class type with const base class prototype
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile10" class="step" data-x="-2600" data-y="800" data-z="0">
        <p class=title>Let's drop unique_ptr for few secs</p>
            <pre><code><p style="text-align:left; font-size:35;">
<strong>MixerInterface</strong> create()
{
    return <strong>Mixer()</strong>;
    // OK - move ctor
}


<strong>MixerInterface</strong> create()
{
    <strong>Mixer</strong> x;
    return x;
    // OK - copy ctor
}
            </p></code></pre>
        <div class=notes>
        <p>- let's drop unique_ptr
        <p>- object slicing
        <p>- why not copy elision?
        <p>- rval, move ctor, as expected
        <p>- lval, copy ctor, why?</p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile11" class="step" data-x="-1300" data-y="800" data-z="0">
            <p>c++11
            <p>gcc 4.9.2
            <p>custom make_unique()
            <p>www.godbolt.org
        <div class=notes>
        <p>-
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile12" class="step" data-x="-1300" data-y="1600" data-z="0">
            non-compiling examples on gcc 5.1+
            <pre><code><p style="text-align:left; font-size:26;">
unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>Mixer</strong>>();
    return <strong>mixer</strong>;
    // OK - move ctor
}
unique_ptr&ltMixerInterface>::
unique_ptr&ltMixer>(unique_ptr&ltMixer>&& u)


unique_ptr&lt<strong>const MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>MixerInterface</strong>>();
    return mixer;
    // OK - move ctor
}
unique_ptr&ltMixerInterface const>::
unique_ptr&ltMixerInterface>(unique_ptr&ltMixerInterface>&& u)

            </p></code></pre>
        <div class=notes>
        <p>- non-compiling examples on newer compiler - ok
        <p>- move ctor - as expected
        <p>- we assumed that it's a compiler error
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile13" class="step" data-x="-1300" data-y="2400" data-z="0">
            object slicing on gcc 8.1+
            <pre><code><p style="text-align:left; font-size:30;">
MixerInterface create()
{
    Mixer x;
    return x;
    // OK - move ctor now!
}
            </p></code></pre>
            <img src=images/nonCompile/create_gcc.png>
        <div class=notes>
        <p>- object slicing again
        <p>- newer compiler
        <p>- still compiles but now move ctor instead of copy ctor
        </p>
        </div>
        </div>
        <div id="compile14" class="step" data-x="-1300" data-y="3200" data-z="0">
            object slicing on latest clang 8.0.0
            <pre><code><p style="text-align:left; font-size:30;">
MixerInterface create()
{
    Mixer x;
    return x;
    // OK - still copy ctor
}
            </p></code></pre>
            <img src=images/nonCompile/create_clang.png>
        <div class=notes>
        <p>- on clang still copy ctor
        <p>- weird
        </p>
        </div>
        </div>
        <div id="compile15" class="step" data-x="-2600" data-y="3200" data-z="0">
        <p style="font-size:60;">Summary:</p>
        <p>unique_ptr to class hierarchy doesn't compile on gcc 4.9.4-
        <p>it compiles on gcc 5.1+
        <p>object slicing performs copy on gcc 8.0-
        <p>object slicing performs move on gcc 8.1+
        <p>object slicing performs copy on clang 8.0.0
        <p><br><strong>Pretty messed up</strong></p>
        </div>
<!-- =================================================================================================== -->
<!--                                    Chapter II - Copy elision                                        -->
<!-- =================================================================================================== -->
        <div id="copyElision1" class="step" data-x="1300" data-y="0" data-z="0">
        <p class=title2>Copy elision</p>
        <div class=notes>
        <p>- Ok so let's structurize our knowledge a litte and go briefly from the beginnig. What is copy elision?
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision2" class="step" data-x="2600" data-y="0" data-z="0" style="text-align:left;">
        <p>- mechanism that is permitted under certain conditions
        <p>- allowed, not required
        <p>- omit copy/move ctors
        <p>- even if ctor/dtor have side efects
        <p>- objects constructed directly in the storage they'd be copied to
        <p>- copy/move ctors need to be present anyway
        <p>- debug mode
        </p>
        <div class=notes>
        <p>-
        </p>
        It's a mechanism that under certain conditions allows compiler, but not requires to, to omit copy and move constructors, even if the copy/move constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to.
        This is an optimization: even when it takes place and the copy/move constructor is not called, it still must be present and accessible.
        Because some compilers do not perform copy elision in every situation where it is allowed (e.g., in debug mode), programs that rely on the side-effects of copy/move constructors and destructors are not portable.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision3" class="step" data-x="3900" data-y="0" data-z="0">
        <p>C++ standard wording</p>
        <img src=images/copyElision/copy_elision_standard_cpp14.PNG>
        <div class=notes>
        <p>- see wording
        <p>- a lot of text and there's a reason
        <p>- compiler allowed but not obligated to elide
        <p>- 4 situations
        <p>- on fun return, local variable, purpose of life is to be copied, types the same
        <p>- for throw statement
        <p>- init with temporary (also the same type)
        <p>- for exception handler
        <p>- quote from cpp14, cpp17 just little reworded
        </p>
        Let's see whats wording of standard for this. Actually there're a lot of text and there's a reason for this,
        but we can just focus on highlited part. It says that compiler is allowed but now obligated to elide copies and
        there're 4 specific situations where it can be done. On function return, where the variable to be copied 
        is a local, it's only purpose of life is to be copied to caller function and it's type is the same as type in
        function prototype.
        Then there's case for copy elision in throw statement, then for object initialization with a temporary object
        which also need to be of the same type as object being initialized and in the end there's copy elision for
        exception handler. We're going to consider these two mainly.
        This is quote from cpp14, cpp17 is just a little reworded.
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="copyElision4" class="step" data-x="3900" data-y="800" data-z="0">
        <p class="title2">Copy elision - extracted<br><br></p>
        <p>- automatic storage
        <p>- the same type
        <p>- results "as if" copies were made
        <div class=notes>
        <p>-
        </p>
        </div>
        </div>      
<!-- =================================================================================================== -->            
        <div id="copyElision5" class="step" data-x="3900" data-y="1600" data-z="0">
        <p class=title>RVO, NRVO</p>
        
            <pre><code><p style="text-align: left">
            <img style="float:right;" src=images/copyElision/copy_elision_fun1.PNG>
Mixer fun1() {
    return Mixer{};
    // RVO
}
            <img style="float:right;" src=images/copyElision/copy_elision_fun2.PNG>
Mixer fun2() {
    Mixer x;
    return x;
    // NRVO
}
            </p></code></pre>
        <div class=notes>
        <p>- let's see few examples
        <p>- simple RVO and NRVO case
        <p>- unnamed in 1st and named in 2nd object returned
        <p>- assembly code on the right, only default ctor called
        </div>
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision6" class="step" data-x="3900" data-y="2400" data-z="0">
        <p class=title>init objects with temporary</p>
            <pre><code><p style="text-align: left;">
            <img style="float:right;" src=images/copyElision/copy_elision_fun3.PNG>
void fun3(Mixer x) {...}

int main() {
    // create arg with temp object
    fun3(Mixer{});
}

    
            
// create var with temp object <img style="float:right;" src=images/copyElision/copy_elision_x1.PNG>
Mixer x1 = Mixer{};
            </p></code></pre>
        <div class=notes>
        <p>- initializaion of fun arg with pure rvalue
        <p>- initialization of variable with pure rvalue
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision7" class="step" data-x="2600" data-y="2400" data-z="0">
        <p class=title>copy elision combined</p>
            <pre><code><p style="text-align: left">
// RVO + create var with temp object
Mixer x2 = fun1(); <img style="float:right;" src=images/copyElision/copy_elision_x2.PNG>



// RVO + create arg with temp object
fun3(fun1());   <img style="float:right;" src=images/copyElision/copy_elision_fun3_fun1.PNG>
            </p></code></pre>
        <div class=notes>
        <p>- copy elision can be combined to avoid multiple copies
        <p>- RVO with initialization with temporary object
        <p>- of variable
        <p>- and of fun arg 
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision8" class="step" data-x="2600" data-y="1600" data-z="0">
        <p class=title>Copy elision for exceptions</p>
            <img style="float:right;" src=images/copyElision/copy_elision_fun4.PNG>     
            <pre><code><p style="text-align: left">
void fun4() {
    // copy-elision in
    // throw-expression
    throw Mixer{};
}
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision9" class="step" data-x="2600" data-y="800" data-z="0">
            <img style="float:right;" src=images/copyElision/copy_elision_fun5.PNG>
            <pre><code><p style="text-align: left">
void fun5() {
    // copy-elision in
    // throw-expression
    // no?
    Mixer x;
    throw x;
}
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision10" class="step" data-x="1300" data-y="800" data-z="0">
            <img style="float:right;" src=images/copyElision/copy_elision_fun6.PNG>
            <pre><code><p style="text-align: left">
void fun6() {
    try {
        fun5();
    }
    catch (Mixer x) {
        // copy-elision in
        // exception-handler
        // no?
        // no move ctor - fine
    }
}
            </p></code></pre>
        <div class=notes>
        <p>- C++14 standard has note saying that exception object is always lvalue so no move possible
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision11" class="step" data-x="1300" data-y="1600" data-z="0">
        <p class=title>Branching</p>
            <pre><code><p style="text-align: left">
// no RVO
Mixer create1(int q) {
    Mixer x1, x2;
    if(q > 4)
        return x1;
    else
        return x2;
}
            </p></code></pre>
        <div class=notes>
        <p>- no RVO cause needs to know which object to put into caler storage
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision12" class="step" data-x="1300" data-y="2400" data-z="0">
            <pre><code><p style="text-align: left">
// optimized for RVO
Mixer create2(int q) { 
    if(q > 4) {
        Mixer x1, x2;
        return x1;
    }
    else {
        Mixer x1, x2;
        return x2;
    }
}
            </p></code></pre>
        <div class=notes>
        <p>- smart compiler can optimise to this - RVO
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision13" class="step" data-x="1300" data-y="3200" data-z="0">
            <pre><code><p style="text-align: left">
bool pred(Mixer& x1, Mixer& x2)
{
    return x1 > x2;
}


// no RVO possible
Mixer create3(int q) {
    Mixer x1, x2;
    if(pred(x1,x2))
        return x1;
    else
        return x2;
}           </p></code></pre>
        <p>Never depend on side effects in move/copy ctor, as small change in code can allow or inhibit RVO.</p>
        <div class=notes>
        <p>- no RVO cause both objects need to be created before decision which should be returned
        <p>- never depend on side effects from copy/move ctors
        <p>- small change may allow or inhibit RVO
        </p>
        </div>          
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision14" class="step" data-x="2600" data-y="3200" data-z="0">
        <p class=title>What's magic behind copy elision</p>
        <pre class=left><code>
Mixer fun() {
    int z;
    Mixer x;
    return x;
}

Mixer y{fun()};
        </code></pre>
        <p>How many params fun() takes?
        <div class=notes>
        <p>- mechanics behind c.e.
        <p>- we have function returning object by value and object returned with it
        <p>- how many params fun() takes?
        </p>

        </div>    
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision15" class="step" data-x="3900" data-y="3200" data-z="0">
        <p>0 params</p>
        <p>?</p>
        <p>1 param</p>

        <div class=notes>
        <p>- 
        </p>

        </div>
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision16" class="step" data-x="3900" data-y="4000" data-z="0">
        <img src=images/copyElision/fun_stack1.PNG>
        <p><br>1 param
        <div class=notes>
        <p>- actually 1 parameter
        </div>
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision17" class="step" data-x="2600" data-y="4000" data-z="0">
        <img src=images/copyElision/fun_stack2.PNG>
        <div class=notes>
        <p>- on assmebly level, address of return value to store returned object to
        </div>
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision18" class="step" data-x="1300" data-y="4000" data-z="0">
        <img style="float:right" src=images/copyElision/fun_stack3.PNG>
        <pre class=left><code>
        Mixer fun() {
            int z;
            Mixer x;
            return x;
        }
        
        Mixer y{fun()};
        </code></pre>
        <div class=notes>
        <p>- in this example fun creates 2 local objects and has info on address of return value
        </div>
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision19" class="step" data-x="5200" data-y="0" data-z="0">
        <p class==title>No copy elision</p>
        <img style="float:right" src=images/copyElision/fun_stack4.PNG>
        <pre class=left><code>
        Mixer fun() {
            int z;
            Mixer x;
            return x;
        }
        
        Mixer y{fun()};
        </code></pre>
        </div>
<!-- =================================================================================================== -->        
        <div id="copyElision20" class="step" data-x="5200" data-y="800" data-z="0">
        <p class==title>Copy elision</p>
        <img style="float:right" src=images/copyElision/fun_stack5.PNG>
        <pre class=left><code>
        Mixer fun() {
            int z;
            Mixer x;
            return x;
        }
        
        Mixer y{fun()};
        </code></pre>
        </div>  
<!-- =================================================================================================== -->        
        <div id="copyElision21" class="step" data-x="5200" data-y="1600" data-z="0">
        <p class=title>RVO in C++17</p>
        <pre><code><p style="text-align: left">
struct Factory {
  Factory(){};
  Factory(const Factory &) = delete;
  Factory(Factory &&) = delete;
};

Factory getFactory() { return Factory{}; }
   
   
// C++11/14
<strong>error</strong>: use of deleted function
       'Factory::Factory(Factory&&)'
        </p></code></pre>
        <div class=notes>
        <p>- c11, c14 main problem - can't get rid of copy/move ctor
        <p>- copy elision might not take place
        <p>- this limitation prevents non-movable types from having functions that return by value
        <p>- such as factories
        <p>- we need to reach out for singletons
        </p>
        In C++11 and C++14 the main problem is that, without guaranteed elision, you cannot get rid of the move and copy constructor,
        because elision might not take place. This prevents non-movable types from having functions that return by value,
        such as factories.
        </div>    
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision22" class="step" data-x="5200" data-y="2400" data-z="0">
        <p class=title>"Guaranteed copy elision through simplified value categories"</p>
        <br>
        <p class=left>- prvalue - initializer of object</p>
        <p class=left>- glvalue - location of object</p>
        <p class=left>- if prvalue is used as the initializer of an object with the same type, it initializes it directly
        <p class=left>- value returned from function, when init with temporary, is initialized directly, no copy/move
        <p class=left>- no copy/move ctor needed
        <div class=notes>
        <p>- name of proposal
        <p>- distinguish between prvalue and temp objects initialized by them
        <p>- glvalue - defined as location of object
        <p>- prvalue - define as initializer of object
        <p>- prvalue initializes object directly
        <p>- as a consequence, init ...
        <p>- no copy, no move
        <p>- move/copy ctors not needed
        </p>
        The complete name of the proposal is ...
        To achieve guaranteed copy elision, the proposal suggests distinguishing between prvalue (pure rvalue) expressions
        and the temporary objects initialized by them. More specifically, a glvalue (generalized lvalue) is defined
        as the location of an object and a prvalue is defined as the initializer of the object.
        If a prvalue is used as the initializer of an object with the same type, it initializes it directly.
        As a consequence, initializing the return value of a function with a temporary causes the value to be initialized directly,
        without a copy or a move. This means that the copy or move constructor of the object no longer needs to be accessible.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision23" class="step" data-x="5200" data-y="3200" data-z="0">
        <p class=title>Actually...</p>
        <pre class=left><code>
auto factory = getFactory(); // OK in C++17
        </code></pre>
        <p class=left>- it's not copy elision anymore
        <p class=left>- no copy to elide
        <p class=left><strong>- deferred temporary materialization</strong></p>
        <div class=notes>
        <p>- by definition there's no copy to elide
        </div>
        </div>
<!-- =================================================================================================== -->
<!--                                    Chapter II - Move                                         -->
<!-- =================================================================================================== -->
        <div id="Move1" class="step" data-x="7800" data-y="0" data-z="0">
        <p class=title>When copy elision not eligible...</p>
        <p>then create new object</p>
        <br><br>
        <p class=title2>copy or <strong>move</strong></p>
        <div class=notes>
        <p>- we just went through [...] but why?
        <p>- still keep in mind non compile?
        <p>- we remember that compiler error was [...]
        <p>- be patient, we're getting there
        <p>- when no copy elision, then create object
        <p>- move/copy - what criteria?
        </p>
        Ok, we've just went through copy elision criteria and examples but why? We still keep in mind our non compiling 
        examples from previous secion right? We remember that compiler error was that 
        it wanted to call converting move ctor but had only lvalue object so printed en error right? Be patient, we're getting there. 
        
        So on function return, when copy elision is not eligible, new object needs to be created. It can be created using
        move or copy ctor. What are criteria that compiler uses to take this decision?
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move2" class="step" data-x="9100" data-y="0" data-z="0">
        <p class=title>Move or copy?</p>
        <pre class=left><code>
Mixer fun1() {
    // easy - rvalue so move ctor
    return Mixer{};
}



Mixer fun2() {
    // but here's lvalue...
    Mixer x;
    return x;
}
        </code></pre>
        <div class=notes>
        <p>- fun1()
        <p>- fun2()
        <p>- performance issue
        <p>- nice to have a mechanism that allowes move here
        <p>- actually there's one
        </p>
        lvalue so should be copy ctor but obviously it would be performance issue. So it would be nice 
        to have a mechanism that allowed to do move operation here. Actually there's one.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move3" class="step" data-x="10400" data-y="0" data-z="0">
        <p class=title>C++11* criteria for RVO with move</p>
        <br><br>
        <img src=images/rvoMove/cpp11_move_criteria.PNG>
        <div class=notes>
        <p>- highlited
        <p>- tied closely with crit for c.e.
        <p>- only diff - can be used for fun param
        <p>- treat lvalue object as rvalue and overload ctor
        <p>- if fails overload again treating as lvalue 
        <p>- fun2() - move op
        <p>- compulsory, not as with c.e.
        </p>
        A lot of test but don't worry, again we'll just focus on highlited part. 
        Criteria for creation of new object with move op are tied closely with criteria for copy elision, the only 
        difference is it can be used for fun param.
        In example fun2 works fine here.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move4" class="step" data-x="10400" data-y="800" data-z="0">
        <p class=title>So move instead of copy elision but criteria tied closely...</p>
        <br><br>
        <p class=left>- when -fno-elide-constructors</p>
        <p class=left>- when decision not to perform copy elision as it's not mandatory
        <p class=left>- when fun param
        <div class=notes>
        <p>- even if eligible for copy elision, might have decided, as prev section
        </p>
        So when can we use it when criteria for copy elision are met but copy elision is not performed?
        For sure when compiling with - fno-elide-constructors flag. But remember also that copy elision in cpp11 and cpp14
        is not required, so even when sth is eligible to copy elision, compiler engineers might have decided not to do so,
        as in example with exception in previous section.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move5" class="step" data-x="10400" data-y="1600" data-z="0">
        <p class=title>DR1579</p>
        <p class=link>http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1579</p>
        <p class=link>2012-2014
        <p>
        <img src=images/rvoMove/DR1579.PNG>
        <div class=notes>
        <p>- after some research
        <p>- DR
        <p>- similar situation
        </p>
        Similar situation to ours but with optional, but the same problem noticed - converting ctor can't be used
        without explicit std::move on return value. Reported in 2012, resolved in 2014.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move6" class="step" data-x="10400" data-y="2400" data-z="0">
        <p class=title>DR1579 resolution</p>
        <img src=images/rvoMove/DR1579_resolution.PNG>
        <p class=left> wording in C++14
        <p class=left> added retrospectively to C++11 with C++14 standard publication
        <p>
        <div class=notes>
        <p>-
        </p> 
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move7" class="step" data-x="9100" data-y="2400" data-z="0" style="font-size:30">
        <pre class=left><code>
unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>Mixer</strong>>();
    return <strong>mixer</strong>;
}       </code></pre>
        <p><strong>pre</strong> DR1579 compiler reasoning:
        <p class=left>- can I perform copy elision? No, types are different.
        <p class=left>- let's create new object on stack
        <p class=left>- can I treat object as rvalue and try to use move ctor for this?
        <p class=left>- no, criteria here are tied with copy elision.
        <p class=left>- ctor overload resolution with lvalue
        <p class=left>- dammit, only move converting ctor available, error.
        <div class=notes>
        <p>- let's go back to our non-compiling example
        <p>- ...
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move8" class="step" data-x="9100" data-y="1600" data-z="0" style="font-size:30">
        <pre class=left><code>
unique_ptr&lt<strong>const MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>MixerInterface</strong>>();
    return mixer;
}       </code></pre>
        <p><strong>post</strong> DR1579 compiler reasoning:
        <p class=left>- can I perform copy elision? No, types are different.
        <p class=left>- let's create new object on stack
        <p class=left>- can I treat object as rvalue and try to use move ctor for this?
        <strong>
        <p class=left>- yes, it's an object with automatic storage duration, go ahead
        <p class=left>- ctor overload successful, converting move ctor chosen
        </strong>
        <div class=notes>
        <p>- post defect compiler reasoning was like this:
        <p>- ...
        <br>=========================================
        <p>- This finding explains non-compiling problems. Old compiler was using C++11 return move semantics criteria, so ended up throwing an error.
        <p>- newer compiler follows new rules that are not so tightly coupled with copy elision criteria
        <p>- object of automatic storage doesn't have to be of the same type as fun prototype anymore so object can be treated as rvalue and move ctor overload can be resolved
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move9" class="step" data-x="9100" data-y="800" data-z="0" style="font-size:30">
        <p style="font-size:40">So why object slicing compiled on old compiler?</p>
        <pre class=left><code>
<strong>MixerInterface</strong> create()
{
    <strong>Mixer</strong> x;
    return x;
}
        </code></pre>
        <div class=notes>
        <p>- Ok so one can ask why object slicing didn't fail on old compiler?
        <p>- We have similar situation, with different types returned and to be returned.
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move10" class="step" data-x="7800" data-y="800" data-z="0">
        <p class=title>Return statement</p>
        <p class=left>- evaluates the expression
        <p class=left>- terminates current function
        <p class=left>- and returns the result of the expression to the caller,
        <p class=left>- after implicit conversion to the function return type. 
        <div class=notes>
        <p>- when we look at return statement description
        <p>- ...
        <p>- implicit converion is important for us
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move11" class="step" data-x="7800" data-y="1600" data-z="0" style="font-size:30">
        <pre class=left><code>
<strong>MixerInterface</strong> create()
{
    <strong>Mixer</strong> x;
    return x;
}       </code></pre>
        <p><strong>pre</strong> DR1579 compiler reasoning:
        <p class=left>- can I perform copy elision?
        <br>- no cause different types.
        <br>- let's create new object on stack
        <br>- evaluate expression.
        <br>- can I treat object as rvalue and try to use move ctor for this?
        <br>- no, since criteria are the same as for copy elision.
        <br>- so need to treat it as lvalue.
        <br>- implicit cast to return type
        <br>- ctor overload resolution - copy ctor
        <p>
        <p class=left>In unique_ptrs both decisions were also negative.
		<br>But no implicit cast nor copy ctor were available.
        <div class=notes>
        <p>- 
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move12" class="step" data-x="7800" data-y="2400" data-z="0" style="font-size:30">
        <pre class=left><code>
<strong>MixerInterface</strong> create()
{
    <strong>Mixer</strong> x;
    return x;
}       </code></pre>
        <p><strong>post</strong> DR1579 compiler reasoning:
        <p class=left>- can I perform copy elision?
        <br>- no cause different types.
        <br>- let's create new object on stack
        <br>- evaluate expression.
        <br>- can I treat object as rvalue and try to use move ctor for this?
        <br><strong>- yes, it's an object with automatic storage duration, go ahead
        <br>- type of ctor arg is not rvalue ref to its param's type</strong>
        <br>- so need to treat as lvalue
        <br>- implicit cast to return type
        <br>- ctor overload resolution - copy ctor
        <div class=notes>
        <p>- newer comp reasons the same
        <p>- for decision whether use move ctor uses different from copy elision
        <p>- so tries to overload ctor with rval ref
        <p>- overload fails bc no converting ctor for base class present
        <p>- the rest of mechanism is the same
        </p>
        Newr compiler, with bug fixed reasons the same, but for decision whether to use move ctor doesn't use criteria
        for copy elision but tries to overload ctor with rvalue reference. Overload fails bc base class doesn't have 
        converting ctor with param of type of Mixer. The rest of mechanism is the same.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move13" class="step" data-x="7800" data-y="3200" data-z="0">
        <p class=title>Back to object slicing copy/move problem</p>
        <p>Why gcc 8.1+ uses move?</p>
        <pre class=left><code>MixerInterface create()
{
    Mixer x;
    return x;
    // gcc 8.1+     - move ctor
    // gcc 8.0-     - copy ctor
    // clang 8.0.0  - copy ctor
    // c++ standard - copy ctor
}</code></pre>
        gcc is ahead of standard, there's a proposal
        <div class=notes>
        <p>- last question to answer
        <p>- why ...
        <p>- copy is conformant to standard
        <p>- gcc engineers try to be clever here and are ahead
        <p>- there's a proposal suggesting to standardize such case
        </p>
        We have last question to answer - why in this example pre 8.0 gcc and all clang is performing a copy and gcc+ is doing move?
        Actually it's the copy that is conformant with standard. But gcc engineers try to be clever and are little bit ahead here,
        there's a proposal that suggests resolving move ctor in such case. 
        </div>
        </div>
<!-- =================================================================================================== -->
<!--                                    Chapter IV - Future of RVO move semantics                        -->
<!-- =================================================================================================== -->
        <div id="Future1" class="step" data-x="1300" data-y="-3000" data-z="0">
        <p class=title>Current/future RVO optimization proposals</p>
        <div class=notes>
        <p>- we went so far through few examples
        <p>- not a simple choice and evolving
        <p>- in what state is it now?
        <p>- already seen wording for c++11, 14, 17 modifies
        <p>- what's next or currently?
        <p>- 3 proposals, regarding enhancing criteria
        </p>
        So generally we went through non compiling examples on old compilers, examples that currently on one compiler
        are copied and on the other are moved, we can cleary see that decision how create objects on return 
        is not a simple choice and is still evolving. So in what state it is now?
        We've already seen wording for cpp11 and cpp14 standard, cpp17 modifies it a little with deferred temporary materialization.
        What's next? Or... actually currently. There're already 3 proposals being processed,
        regarding enhancing criteria for either copy elision or creating objects on return with move operation.
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future2" class="step" data-x="2600" data-y="-3000" data-z="0">
        <p class=title>
        P0527R1<br>
        Implicitly move from rvalue references in return statements</p>
        <p>David Stone</p>
        <p>2017</p>
        <p class=link>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0527r1.html</p>
        <div class=notes>
        <p>-
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future3" class="step" data-x="3900" data-y="-3000" data-z="0">
        <pre class=left><code>
unique_ptr<T> fun(unique_ptr<T> && ptr) {
    return ptr;
    //could go with return move(ptr);
}
        </code></pre>
        <p class=left>error: use of deleted function<br>
        'unique_ptr<T>::unique_ptr(const unique_ptr<T>&)'</p> 

        <div class=notes>
        <p>- compiler error bc it's not automatic storage duration
        <p>- could fix be move
        <p>- may not sound that bad but...
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future4" class="step" data-x="5200" data-y="-3000" data-z="0">
        <p class=title>consider generic case</p>
        <pre class=left><code>
auto fun(args...) {
    decltype(auto) result = some_other_fun();
    return forward&ltdecltype(result)>(result);
}
        </code></pre>
        <p class=left>with std::forward, RVO inhibited when result is a value and not a reference
        <p class=left>without std::forward, doesn't compile when result is rvalue ref and is move only 
        <div class=notes>
        <p>- may not sound that bad but consider generic case
        <p>- fun accepts parameter pack
        <p>- depending on result type, it either doesn't compile or inhibits c.e.
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future5" class="step" data-x="1300" data-y="-3800" data-z="0">
        <p class=title>Surprising results</p>
        <pre class=left><code>
// move ctor
string f(std::string x) { return x; }

// copy ctor - quite surprising...
string g(string && x) { return x; }
        </code></pre>
        <div class=notes>
        <p>- ...
        <p>- assuming no copy elision
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future6" class="step" data-x="2600" data-y="-3800" data-z="0">
        <p class=left>- Similar suggestions regarding rvalue reference function parameters used in 
        throw expression and exception declaration.
        <p class=left>- Wording change to include rvalue reference:<br>
        "an object with automatic storage duration" -> "a movable entity"
        <p><br><br><br>Proposal was approved by EWG in the Kona 2017 meeting.</p>
        <div class=notes>
        <p>-
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future7" class="step" data-x="3900" data-y="-3800" data-z="0">
        <p class=title>
        P1155R2<br>
        More implicit moves</p>
        <p>Arthur O'Dwyer<br>
        David Stone</p>
        <p>2018-future</p>
        <p class=link>http://quuxplusone.github.io/draft/d1155-more-implicit-moves.html</p>
        <div class=notes>
        <p>- on open-std R1 from November
        <p>- here R2 from January
        <p>- presented on cppcon 2018
        <p>- great talk, just half an hour
        </p> 
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future8" class="step" data-x="5200" data-y="-3800" data-z="0">
        <p class=title>Paper starts with:</p><br>
        <p class=left>"Programmers expect <strong>return x;</strong> to trigger copy elision; or, at worst, to implicitly move from x instead of copying.
        Occasionally, C++ violates their expectations and performs an expensive copy anyway. [...]"</p>
        <div class=notes>
        <p>- paper starts with this quote
        <p>- programmes often expect copy elision or at leas move op, but get expensive copy instead
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future9" class="step" data-x="1300" data-y="-4600" data-z="0">
        <p class titile>Current iso cpp wording has issues</p><br>
        <img src=images/proposals/cpp17_wording_issues.PNG>
        <div class=notes>
        <p>- present current c++ standard wording and points out issues:
        <p>- other than function parameter
        <p>- only constructor
        <p>- type of rvalue reference
        <p>- the same type
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future10" class="step" data-x="2600" data-y="-4600" data-z="0">
        <p class=title>- Throwing is pessimized</p>
        <pre class=left><code>
void seven(Widget w) {
    throw w;
}        </code></pre>
        <p class=left>Throw function parameter -
        <br>no copy elision, and no implicit move (the object is copied)
        <p class=left>Note:</p>
        <table id="table_style">
          <tr>
            <td>current Standard wording</td>
            <td>- copy</td>
          </tr>
          <tr>
            <td>GCC</td>
            <td>- copy</td>
          </tr>
          <tr>
            <td>Clang 4.0.1+, MSVC 2015+, ICC 16.0.3+</td>
            <td>- implicit move</td>
          </tr>  
        </table>         
        <div class=notes>
        <p>- paper goes with simple examples as c.e or move construction
        <p>- we've been through most of them
        <p>- switches to examples that surprise
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future11" class="step" data-x="3900" data-y="-4600" data-z="0">
        <p class=title>- Non-constructor conversion is pessimized</p>
        <pre class=left><code>
struct To {
    operator Widget() const &;
    operator Widget() &&;
};

Widget nine() {
    To t;
    return t;
}        </code></pre>
        <p class=left>Conversion operator instead of ctor -
        <br>no copy elision, and no implicit move (the object is copied)
        <div class=notes>
        <p>-
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future12" class="step" data-x="5200" data-y="-4600" data-z="0" style="font-size:28px;">
        <p style="font-size:40px">- By-value sinks are pessimized</p>
        <pre class=left><code>
struct Fowl {
    Fowl(Widget);
};

Fowl eleven() {
    Widget w;
    return w;
}        </code></pre>
        <p class=left>Value instead of rvalue ref -
        <br>no copy elision, and no implicit move (the Widget object is copied)
        <p class=left>Note:</p>
        <table id="table_style">
          <tr>
            <td>current Standard wording</td>
            <td>- copy</td>
          </tr>
          <tr>
            <td>Clang, ICC, MSVC</td>
            <td>- copy</td>
          </tr>
          <tr>
            <td>GCC 5.1+</td>
            <td>- implicit move</td>
          </tr>  
        </table>         
        <div class=notes>
        <p>-
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future13" class="step" data-x="1300" data-y="-5400" data-z="0">         
        <p class=title>- Slicing is pessimized</p>
        <pre class=left><code>
Base thirteen() {
    Derived result;
    return result;
}       </code></pre>
        <p class=left>Different object's type -
        <br>no copy elision, and no implicit move (the object is copied)
        <p class=left>Note:</p>
        <table id="table_style">
          <tr>
            <td>current Standard wording</td>
            <td>- copy</td>
          </tr>
          <tr>
            <td>Clang, MSVC</td>
            <td>- copy</td>
          </tr>
          <tr>
            <td>GCC 8.1+, ICC 18.0.0+</td>
            <td>- implicit move</td>
          </tr>  
        </table>         
        <div class=notes>
        <p>- here's our mistery with object slicing
        <p>- remember our example? - old gcc copy, latest clang copy, latest gcc move
        <p>-standard: parameter type of resolved ctor overload should be rvalue ref to object type. So rvalue ref to Derived. And actual params type is rvalue ref to Base
        <p>- according to standard copy, gcc is ahead.
        </p>
        <br>And here's our mistery with object slicing and copy vs move on clang and gcc is solved.
        According to standard copy, gcc is ahead.
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future14" class="step" data-x="2600" data-y="-5400" data-z="0" style="font-size:30px">         
        <p style="font-size:40px">"We propose to remove all four of these unnecessary limitations."</p>
        
        <p class=left>- already implemented in clang (available since 02.2018)
        <p class=left>- -Wreturn-std-move (enabled as part of -Wmove, -Wmost, and -Wall)
        <p class=left>- overload resolution done twice - standard rules and the ones proposed here
        <p class=left>- if they differ, then diagnostic warning is emitted suggesting adding explicit std::move since copy otherwise
        <p class=left>- clang still doesn't diagnose "By value sinks"
        <div class=notes>
        <p>- propose to remove all 4 limitations
        <p>- present quite good study case
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future15" class="step" data-x="3900" data-y="-5400" data-z="0">         
        <p class=title>Feedback from production</p>
        <p><strong>Plenty of true positives</strong><br>
        <p>Proven with clang flag enabled on Chromium and LibreOffice projects</p>
        <p><br><strong>Lack of false positives</strong>
        <p>Just one complaint from Mozzilla saying that performance benefit was too little when compared to ugliness
        of explicit std::move. Actually it's not even mistake.</p>
        <div class=notes>
        <p>- 11 months for feedback
        <p>- R2 - ++x
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future16" class="step" data-x="5200" data-y="-5400" data-z="0">         
        <p class=title>P0889R1<br>
        Ultimate copy elision</p>
        <p>Antony Polukhin</p>
        <p>2018-future</p>
        <p class=link>https://apolukhin.github.io/papers/ultimate_copy_elision_r1.html</p>
        <div class=notes>
        <p>- on open-std R0 ver
        </p>
        </div>
        </div>                
<!-- =================================================================================================== -->        
        <div id="Future17" class="step" data-x="1300" data-y="-6200" data-z="0">         
        <p class=title>A. Teaching practice</p>
        <p class=left>- code with numerous functions since we've been taught for decades to delegate to funs and classes
        <p class=left>- compilers inline more aggressievly and inline a lot
        <div class=notes>
        <p>-
        </p>
        </div>
        </div>                
<!-- =================================================================================================== -->        
        <div id="Future18" class="step" data-x="2600" data-y="-6200" data-z="0">         
        <p class=title>B. Copy elision rules
        <p class=left>- current rules for copy elision mostly assume that a function from source code remains a function in a binary
        <p class=left>- inlining, aliasing reasoning, and link time optimization open new world on possible optimizations since fun params and its body is seen together
        <p class=left>- current rules are suboptimal for modern compilers: they prevent optimizations.
        <div class=notes>
        <p>-
        </p>
        </div>
        </div>                
<!-- =================================================================================================== -->        
        <div id="Future19" class="step" data-x="3900" data-y="-6200" data-z="0">         
        <p class=title>C. std::move/rvalues is not a panacea
        <p>move operation is not a solution since<br><br>
        std::array, std::basic_string, std::function, std::variant, std::optional and others<br><br>
        may store a lot of data on stack
        <div class=notes>
        <p>- if you interested in examples, please reach out to paper
        </p>
        </div>
        </div>                
<!-- =================================================================================================== -->        
        <div id="Future20" class="step" data-x="5200" data-y="-6200" data-z="0">         
        <p class=title>Summary</p>
        <p>year 2002 - the oldest proposal on move semantics found
        <br>move semantics present for almost 2 decades now
        <br>there're still areas to optimize</p>
        <img src=images/proposals/move_semantics_2002_trimmed.PNG>
        <div class=notes>
        <p>-
        </p>
Let's summarize.<br>
I briefly looked for proposals on move semantics and the oldest I found was from 2002.
Even though the idea of move semantics started almost 2 decades ago and is present in standard for almost a decade,
there're optimization areas to work on. That's amazing.         
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future21" class="step" data-x="1300" data-y="-7000" data-z="0">         
        <p class=title>The journey covered</p>
        <p>- non compiling unique_ptr examples
        <p>- copy elision mechanics and rules
        <p>- RVO with move semantics
        <p>- changes and defects in C++11, C++14, C++17
        <p>- new proposals enhancing nr of contexts for copy elision and move object creation on fun return<br>
        <div class=notes>
        <p>-
        </p>
        We've started with non compiling example, then went through copy elision mechanics and rules,
        then through creating new object with move operation on function return and criteria for this in c++11,14,17.
        Finally we've seen current proposals that aim to yet ehnace no of contexts where copy elision or move object creation 
        can be used.
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future22" class="step" data-x="2600" data-y="-7000" data-z="0">         
        <p class=title>Journey memoirs</p>
        <p>- you can't blindly rely on what your compiler tells you
        <p>- upgrade compilers in your projects
        <p>- upgrade C++ standard<br><br>
        <p>- less time on investigating bugs
        <p>- increased performance
        <p>- cleaner codebase</p>
        <div class=notes>
        <p>-
        </p>
        What I'd like you to remember from this thrilling journey we've just had, is that:
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future23" class="step" data-x="3900" data-y="-7000" data-z="0" style="font-size:26px;">
        <p class=title>References</p>         
        <a href=
        "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0527r1.html" style="float:left;">
        [00] David Stone - P0527R1 Implicitly move from rvalue references in return statements
        </a><br>
        <a href=
        "http://quuxplusone.github.io/draft/d1155-more-implicit-moves.html" style="float:left;">
        [01] Arthur O'Dwyer, David Stone - P1155R2 More implicit moves
        </a><br>
        <a href=
        "https://apolukhin.github.io/papers/ultimate_copy_elision_r1.html" style="float:left;">
        [02] Antony Polukhin - P0889R1 Ultimate copy elision
        </a><br>
        <a href=
        "https://www.youtube.com/watch?v=hA1WNtNyNbo" style="float:left;">
        [03] Arthur O'Dwyer - RVO harder than it looks - CppCon 2018
        </a><br>
        <a href=
        "https://www.youtube.com/watch?v=IZbL-RGr_mk" style="float:left;">
        [04] John Kalb - Copy elision - CppCon 2018
        </a><br>
        <a href=
        "https://jonasdevlieghere.com/guaranteed-copy-elision" style="float:left;">
        [05] Jonas Devlieghere - Guaranteed Copy Elision
        </a><br>
        <a href=
        "https://blog.tartanllama.xyz/guaranteed-copy-elision" style="float:left;">
        [06] Simon Brand - Guaranteed Copy Elision Does Not Elide Copies
        </a><br>
        <a href=
        "http://definedbehavior.blogspot.com/2011/08/value-semantics-copy-elision.html" style="float:left;">
        [07] David Rodriguez - Value semantics: Copy elision 
        </a><br>
        <a href=
        "http://definedbehavior.blogspot.com/2011/08/value-semantics-nrvo.html" style="float:left;">
        [08] David Rodriguez - Value semantics: NRVO
        </a><br>
        <a href=
        "https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move"
        style="float:left;">
        [09] Zhao Wu IBM - RVO V.S. std::move
        </a><br>
        <a href=
        "https://www.amazon.com/gp/product/1491903996/ref=dbs_a_def_rwt_bibl_vppi_i0" style="float:left;">
        [10] Scott Meyers - Effective Modern C++
        </a><br>
        <a href=
        "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm" style="float:left;">
        [11]  A proposal to add move semantics support to the C++ Language - 2002
        </a><br>        
        <a href=
        "http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1579" style="float:left;">
        [12]  C++11 RVO defect report
        </a><br>
        <a href=
        "https://en.cppreference.com/w/cpp/language/return" style="float:left;">
        [13]  cppreference - return statement
        </a><br>
        <a href=
        "https://en.cppreference.com/w/cpp/language/copy_elision" style="float:left;">
        [14]  cppreference - copy elision
        </a><br>
        <a href=
        "https://en.cppreference.com/w/cpp/language/value_category" style="float:left;">
        [15]  cppreference - value category
        </a><br>
        <div class=notes>
        <p>-
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="Future24" class="step" data-x="5200" data-y="-7000" data-z="0">         
        <p class=title>Thank you</p><br>
		<p>Lukasz Bondyra</p>
		<p>Senior Engineer @ Motorola Solutions<br><br>
        <p>https://github.com/bondyr/rvo_ppt
        <p>Lkbondyra@gmail.com</p>
        <div class=notes>
        <p>-
        </p>
        </div>
        </div>        
    </div>

    <div class="fallback-message">
        <p>
            Your browser <b>doesn't support the features required</b> by
            impress.js, so you are presented with a simplified version of this
            presentation.
        </p>
        <p>
            For the best experience please use the latest <b>Chrome</b>, <b>Safari</b>
            or <b>Firefox</b> browser.
        </p>
    </div>

    <script type="text/javascript" src="js/impress.js"></script>
    <script type="text/javascript">impress().init();</script>
</body>
</html>


