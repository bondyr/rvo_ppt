<html lang="en">
<head>
<style>
body {
    width: 1024px;
    font-size: 36px;
    font-family: 'Armata', sans-serif;
    background: url(images/pt-2.png);
    color: #eee;
    text-shadow: 1px 1px 2px #000;
}

.title {
    font-size: 50px;
}

.title2 {
    font-size: 60px;
} 

.subtitle {
    vertical-align: top;
    font-size: 40px;
}

.left {
    text-align: left;
}

/* .code_style { */
/*     text-align: left; */
/*     font-family: "Monospace"; */
/* } */

.step {
    text-align: center;
    width: 1024px;
}

.notes {
    display: none;
}

.hint_text {
    margin-top: 120px;
    font-size: 30px;
    background-color: #282a2f;
    padding: 15px;
    border: 1px solid #484d52;
    border-radius: 5px;
    font-size: 18px;
}

.fallback-message {
    color: #eee;
    line-height: 1.3;
    width: 780px;
    padding: 10px 10px 0;
    margin: 20px auto;
    border: 1px solid #E4C652;
    border-radius: 10px;
}

.fallback-message p {
    margin-bottom: 10px;
}

.impress-supported .fallback-message {
    display: none;
}

em {
    font-style: normal;
    border-bottom: 1px solid #484d52;
    padding-bottom: 2px;
    color: #d5a830;
}
</style>
</head>

<body class="impress-not-supported">
    <div id="impress">
<!-- =================================================================================================== -->
        <div id="title" class="step title" data-x="2600" data-y='-2000'>
            <p>When the mix of modern C++ features surprise you</p>
            <div class="notes">
            <p>- Hello
            <p>- warmup
            <p>- talk about mix of modern c++ features
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="overview" class="step" data-x="2600" data-y='0' data-scale='15'>
            <div class="notes">
            <p>- journey</p>

            I’d like to take you for a journey that I set off couple months ago.
            </div>
        </div>
<!-- =================================================================================================== -->
<!--                                    Chapter I - non Compile                                          -->
<!-- =================================================================================================== -->
        <div id="compile1" class="step" data-x="-1300" data-y="0" data-z="0" style="font-size:45px;">
            <p>auto </p>
            <p>unique_ptr</p>
            <p>move</p>
            <br><br>
            <p>RVO</p>
            <div class=notes>
            <p>- started with mix of auto, smart_ptrs, move semantics</p>
            <p>- ended with compiler RVO: copy elisions and move semantics</p>
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile2" class="step" data-x="-2600" data-y="0" data-z="0">
            <pre><code><p style="text-align: left">
class Combiner { ... };

unique_ptr&ltCombiner> create()
{
    auto combiner = make_unique&ltCombiner>();
    combiner->init();
    ...
    return <strong>move(combiner)</strong>;
}
            </p></code></pre>
            <div class=notes>
            <p>- code review, minor mistake
            <p>- factory fun casting to rval
            <p>- lot of tutorials
            <p>- suffer on performance</p>

            When doing review of code, I noticed a piece of code that contained a minor mistake.
            Factory function, that was creating and initializing a unique pointer, on return was casting it to
            rvalue.
            There’re a lot of tutorials on modern c++ saying that you shouldn’t do that, bc you prevent compiler
            optimization and your code will suffer on performance.
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile3" class="step" data-x="-3900" data-y="0" data-z="0">
            <img src=images/nonCompile/Meyers_return_move.PNG>
            <div class=notes>
            <p>- Meyers, puts in frame, "Effective Modern C++"
            <p>- Briefly - prevents RVO, intro move operation
            <p>- anyway if copy elision not allowed

            It's one of the first things you learn when diving into move semantics,
            Scott Meyers also emphasises it properly in his "Effective Modern C++" book.
            So briefly - it prevents compiler from return value optimization and introduces
            a move operation instead, that would be applied here anyway if copy elision was not allowed.
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile4" class="step" data-x="-2600" data-y="0" data-z="0">
            <div class=notes>
            <p>- In this case RVO inhibited
            <p>- different return types
            <p>- logged a comment, went back to other tasks
            <p>- problem</p>

            In this case - RVO would be inhibited bc function return type and actually returned type
            are different - unique_ptr and rvalue reference to unique_ptr.
            So I logged a comment on that you shouldn’t use move on return from function. I also put there
            few links explaining why, a quote with explanation from Meyers book, and went back to other tasks.
            My collegue noticed comment, fixed code in this place and few other places that were also returning
            move and… told me that there’s a problem.
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile5" class="step" data-x="-3900" data-y="800" data-z="10" style="text-align: left;">
            <pre><code><p>
class MixerInterface{...};
class Mixer : public MixerInterface {...};

unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>Mixer</strong>>();
    mixer->init();
    ...
    return <strong>move(mixer)</strong>;
}
            </p></code></pre>
            <div class=notes>
            <p>- almost the same
            <p>- also unique_ptrs
            <p>- only difference - auto
            <p>- returnes derived class</p>
            </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile6" class="step" data-x="-3900" data-y="1600" data-z="20">
            <pre><code><p style="text-align: left; font-size:30;">
unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>Mixer</strong>>();
    mixer->init();
    ...
    return <strong>mixer</strong>;
}



error: cannot bind 'unique_ptr&ltMixer>' lvalue
                to 'unique_ptr&ltMixer>&&'
            </p></code></pre>
        <div class=notes>
        <p>- compiler error
        <p>- no RVO but move ctor (fine)
        <p>- why lvalue error?</p>

        How surprised were we, when it turned out that this function produced compiler error.
        And it was kind of not obvious in the beginning - obviously no RVO happened cause compiler tried
        to fire move ctor for unique_ptr (this is fine bc)
        type of fun prototype and returned object are different), but had only lvalue available.
        Why is there lvalue error?
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile7" class="step" data-x="-3900" data-y="2400" data-z="0">
            <pre><code><p style="text-align:left; font-size:28;">
note: initializing argument 1 of
'unique_ptr<_Tp, _Dp>::unique_ptr(unique_ptr<_Up, _Ep>&&)
[with _Up = Mixer;          _Ep = default_delete<Mixer>;
      _Tp = MixerInterface; _Dp = default_delete<MixerInterface>]'



unique_ptr&lt<strong>MixerInterface</strong>>::unique_ptr(unique_ptr&lt<strong>Mixer</strong>>&& u);



unique_ptr&ltMixerInterface>(mixer);
            </p></code></pre>
        <div class=notes>
        <p>- why not copy ctor
        <p>- converting move ctor</p>

        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile7b" class="step" data-x="-3900" data-y="1600" data-z="0">
        <div class=notes>
        <p>- can't bind lval to rval ref</p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile8" class="step" data-x="-2600" data-y="2400" data-z="0">
            <pre><code><p style="text-align:left; font-size:30;">
unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    return make_unique&lt<strong>Mixer</strong>>();
    // OK - move ctor
}



unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    unique_ptr&lt<strong>MixerInterface</strong>> mixer = make_unique&lt<strong>Mixer</strong>>();
    mixer->init();
    ...
    return mixer;
    // OK - NRVO
}
            </p></code></pre>
        <div class=notes>
        <p>- debugging - compiles
        <p>- return rvalue object directly
        <p>- returns lvalue object of type MixerInterface - NRVO
        </p>
        We started debugging to see what's going on, and checked that these 2 pieces of code are compiled fine.
        </div>
        </div>

<!-- =============================================================================================================== -->
        <div id="compile9" class="step" data-x="-2600" data-y="1600" data-z="0">
            <pre><code><p style="text-align:left; font-size:25;">
unique_ptr&lt<strong>const MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>MixerInterface</strong>>();
    mixer->init();
    ...
    return mixer;
}


error: cannot bind 'unique_ptr&ltMixerInterface>' lvalue
                to 'unique_ptr&ltMixerInterface>&&'


unique_ptr&lt<strong>const MixerInterface</strong>>::unique_ptr(unique_ptr&lt<strong>MixerInterface</strong>>&& u);
            </p></code></pre>
        <div class=notes>
        <p>- further analysis
        <p>- return base class type with const base class prototype
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile10" class="step" data-x="-2600" data-y="800" data-z="0">
            <pre><code><p style="text-align:left; font-size:35;">
<strong>MixerInterface</strong> create()
{
    return <strong>Mixer()</strong>;
    // OK - move ctor
}


<strong>MixerInterface</strong> create()
{
    <strong>Mixer</strong> x;
    return x;
    // OK - copy ctor
}
            </p></code></pre>
        <div class=notes>
        <p>- further testing
        <p>- rval, move ctor, as expected
        <p>- lval, ok but why not NRVO?</p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile11" class="step" data-x="-1300" data-y="800" data-z="0">
            <p>c++11
            <p>gcc 4.9.2
            <p>gcc up to 4.9.4
            <p>www.godbolt.org
        <div class=notes>
        <p>-
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile12" class="step" data-x="-1300" data-y="1600" data-z="0">
            gcc 5.1+
            <pre><code><p style="text-align:left; font-size:20;">
unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>Mixer</strong>>();
    return <strong>mixer</strong>;
    // OK - move ctor
}

unique_ptr&ltMixerInterface>::unique_ptr&ltMixer>(unique_ptr&ltMixer>&& u)



unique_ptr&lt<strong>const MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>MixerInterface</strong>>();
    return mixer;
    // OK - move ctor
}

unique_ptr&ltMixerInterface const>::unique_ptr&ltMixerInterface>(unique_ptr&ltMixerInterface>&& u)

            </p></code></pre>
        <div class=notes>
        <p>- compiler 5.1 - ok
        <p>- move ctor - as expected
        <p>- we assumed that it's a compiler error
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="compile13" class="step" data-x="-1300" data-y="2400" data-z="0">
            gcc 8.1+
            <pre><code><p style="text-align:left; font-size:30;">
MixerInterface create()
{
    Mixer x;
    return x;
    // OK - move ctor now!
}
            </p></code></pre>
            <img src=images/nonCompile/create_gcc.png>
        <div class=notes>
        <p>- newer compiler
        <p>- still compiles but now move ctor instead of copy ctor
        </p>
        </div>
        </div>
        <div id="compile14" class="step" data-x="-1300" data-y="3200" data-z="0">
            latest clang 8.0.0
            <pre><code><p style="text-align:left; font-size:30;">
MixerInterface create()
{
    Mixer x;
    return x;
    // OK - still copy ctor
}
            </p></code></pre>
            <img src=images/nonCompile/create_clang.png>
        <div class=notes>
        <p>- on clang still copy ctor
        </p>
        </div>
        </div>
        <div id="compile15" class="step" data-x="-2600" data-y="3200" data-z="0">
        <p style="font-size:60;">Summary:</p>
        <p>unique_ptr to class hierarchy doesn't compile on gcc 4.9.4-
        <p>it compiles on gcc 5.1+
        <p>class hierarchy performs copy on gcc 8.0-
        <p>class hierarchy performs move on gcc 8.1+
        <p>class hierarchy performs copy on clang 8.0.0
        <p><br><strong>Pretty messed up</strong></p>
        </div>
<!--        <div class="step" data-x="-3900" data-y="3200" data-z="0">
        </div>
        <div class="step" data-x="-3900" data-y="4000" data-z="0">
        </div>
        <div class="step" data-x="-2600" data-y="4000" data-z="0">
        </div>
        <div class="step" data-x="-1300" data-y="4000" data-z="0">
        </div>
        <div class="step" data-x="-5200" data-y="0" data-z="0">asdasda</div>
        <div class="step" data-x="-5200" data-y="800" data-z="0">
        </div>
        <div class="step" data-x="-5200" data-y="1600" data-z="0">
        </div>
        <div class="step" data-x="-5200" data-y="2400" data-z="0">
        </div>
        <div class="step" data-x="-5200" data-y="3200" data-z="0">
        </div>
        <div class="step" data-x="-5200" data-y="4000" data-z="0">
        </div> -->
<!-- =================================================================================================== -->
<!--                                    Chapter II - Copy elision                                        -->
<!-- =================================================================================================== -->
        <div id="copyElision1" class="step" data-x="1300" data-y="0" data-z="0">
        <p class=title2>Copy elision</p>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision2" class="step" style="text-align:left;" data-x="2600" data-y="0" data-z="0">
        <p>- mechanism that is permitted under certain conditions
        <p>- allowed, not required
        <p>- omit copy/move ctors
        <p>- even if ctor/dtor have side efects
        <p>- objects constructed directly in the storage they'd be copied to
        <p>- copy/move ctors need to be present anyway
        <p>- debug mode
        </p>
        </div>
        <div class=notes>
        <p>-
        </p>
        Ok so let's structurize our knowledge a litte and go briefly from the beginnig. What is copy elision?
        It's a mechanism that under certain conditions allows compiler, but not requires to, to omit copy and move constructors, even if the copy/move constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to.
        This is an optimization: even when it takes place and the copy/move constructor is not called, it still must be present and accessible.
        Because some compilers do not perform copy elision in every situation where it is allowed (e.g., in debug mode), programs that rely on the side-effects of copy/move constructors and destructors are not portable.

        </div>
<!-- =================================================================================================== -->
        <div id="copyElision3" class="step" data-x="3900" data-y="0" data-z="0">
        <p>C++ standard wording</p>
        <img src=images/copyElision/copy_elision_standard_cpp14.PNG>
        <div class=notes>
        <p>- see wording
        <p>- a lot of text and there's a reason
        <p>- compiler allowed but not obligated to elide
        <p>- 4 situations
        <p>- on fun return, var is local, purpose of life is to be copied, types the same
        <p>- for throw statement
        <p>- init with temporary (also the same type)
        <p>- for exception handler
        <p>- quote from cpp14, cpp17 just little reworded
        </p>
        Let's see whats wording of standard for this. Actually there're a lot of text and there's a reason for this,
        but we can just focus on highlited part. It says that compiler is allowed but now obligated to elide copies and
        there're 4 specific situations where it can be done. On function return, where the variable to be copied 
        is a local, it's only purpose of life is to be copied to caller function and it's type is the same as type in
        function prototype.
        Then there's case for copy elision in throw statement, then for object initialization with a temporary object
        which also need to be of the same type as object being initialized and in the end there's copy elision for
        exception handler. We're going to consider these two mainly.
        This is quote from cpp14, cpp17 is just a little reworded.
        </div>
        </div>
<!-- =================================================================================================== -->        
        <div id="copyElision4" class="step" data-x="3900" data-y="800" data-z="10">
        <p class="title2">Copy elision - extracted<br><br></p>
        <p>- automatic storage
        <p>- the same type
        <p>- results "as if" copies were made
        <div class=notes>
        <p>-
        </p>
        </div>
        </div>      
<!-- =================================================================================================== -->            
        <div id="copyElision5" class="step" data-x="3900" data-y="1600" data-z="20">
        <p class=title>RVO, NRVO</p>
        
            <pre><code><p style="text-align: left">
            <img style="float:right;" src=images/copyElision/copy_elision_fun1.PNG>
Mixer fun1() {
    ...
    return Mixer{};
    // RVO
}
            <img style="float:right;" src=images/copyElision/copy_elision_fun2.PNG>
Mixer fun2() {
    Mixer x;
    ...
    return x;
    // NRVO
}
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision6" class="step" data-x="3900" data-y="2400" data-z="300">
        <p class=title>init objects with temporary</p>
            <pre><code><p style="text-align: left;">
            <img style="float:right;" src=images/copyElision/copy_elision_fun3.PNG>
void fun3(Mixer x) {...}

int main() {
    // create arg with temp object
    fun3(Mixer({});
}

    
            
// create var with temp object <img style="float:right;" src=images/copyElision/copy_elision_x1.PNG>
Mixer x1 = Mixer{};
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision7" class="step" data-x="2600" data-y="2400" data-z="0">
        <p class=title>copy elision combined</p>
            <pre><code><p style="text-align: left">
// RVO + create var with temp object
Mixer x2 = fun1(); <img style="float:right;" src=images/copyElision/copy_elision_x2.PNG>



// RVO + create arg with temp object
fun3(fun1());   <img style="float:right;" src=images/copyElision/copy_elision_fun3_fun1.PNG>
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision8" class="step" data-x="2600" data-y="1600" data-z="0">
        <p class=title>Copy elision for exceptions</p>
            <img style="float:right;" src=images/copyElision/copy_elision_fun4.PNG>     
            <pre><code><p style="text-align: left">
void fun4() {
    // copy-elision in
    // throw-expression
    throw Mixer{};
}
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision9" class="step" data-x="2600" data-y="800" data-z="0">
            <img style="float:right;" src=images/copyElision/copy_elision_fun5.PNG>
            <pre><code><p style="text-align: left">
void fun5() {
    // copy-elision in
    // throw-expression
    // no?
    Mixer x;
    throw x;
}
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision10" class="step" data-x="1300" data-y="800" data-z="0">
            <img style="float:right;" src=images/copyElision/copy_elision_fun6.PNG>
            <pre><code><p style="text-align: left">
void fun6() {
    try {
        fun5();
    }
    catch (Mixer x) {
        // copy-elision in
        // exception-handler
        // no?
        // no move ctor - fine
    }
}
            </p></code></pre>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision11" class="step" data-x="1300" data-y="1600" data-z="0">
        <p class=title>Branching</p>
            <pre><code><p style="text-align: left">
// no RVO
Mixer create1(int q) {
    Mixer x1, x2;
    if(q > 4)
        return x1;
    else
        return x2;
}
            </p></code></pre>
        <div class=notes>
        <p>- no RVO cause needs to know which object to put into caler storage
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision12" class="step" data-x="1300" data-y="2400" data-z="0">
            <pre><code><p style="text-align: left">
// optimized for RVO
Mixer create2(int q) { 
    if(q > 4) {
        Mixer x1, x2;
        return x1;
    }
    else {
        Mixer x1, x2;
        return x2;
    }
}
            </p></code></pre>
        <div class=notes>
        <p>- wise compiler can optimise to this - RVO
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision13" class="step" data-x="1300" data-y="3200" data-z="0">
            <pre><code><p style="text-align: left">
bool pred(Mixer& x1, Mixer& x2)
{
    return x1 > x2;
}


// no RVO possible
Mixer create3(int q) {
    Mixer x1, x2;
    if(pred(x1,x2))
        return x1;
    else
        return x2;
}           </p></code></pre>
        <p>Never depend on side effects in move/copy ctor, as small change in code can allow or inhibit RVO.</p>
        <div class=notes>
        <p>- no RVO cause both objects need to be created before decision which should be returned
        <p>- never depend on side effects from copy/move ctors
        <p>- small change may allow or inhibit RVO
        </p>
        </div>          
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision14" class="step" data-x="2600" data-y="3200" data-z="0">
        <p class=title>What's magic behind copy elision</p>
        <pre class=left><code>
Mixer fun() {
    int z;
    Mixer x;
    return x;
}

Mixer y{fun()};
        </code></pre>
        <p>How many params fun() takes?
        <div class=notes>
        <p>- mechanics behind c.e.
        </p>

        </div>    
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision15" class="step" data-x="3900" data-y="3200" data-z="0">
        <p>0 params</p>
        <p>?</p>
        <p>1 param</p>

        <div class=notes>
        <p>- 
        </p>

        </div>
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision16" class="step" data-x="3900" data-y="4000" data-z="0">
        <img src=images/copyElision/fun_stack1.PNG>
        <p><br>1 param
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision17" class="step" data-x="2600" data-y="4000" data-z="0">
        <img src=images/copyElision/fun_stack2.PNG>
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision18" class="step" data-x="1300" data-y="4000" data-z="0">
        <img style="float:right" src=images/copyElision/fun_stack3.PNG>
        <pre class=left><code>
Mixer fun() {
    int z;
    Mixer x;
    return x;
}

Mixer y{fun()};
        </code></pre>
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision19" class="step" data-x="5200" data-y="0" data-z="0">
        <img style="float:right" src=images/copyElision/fun_stack4.PNG>
        <pre class=left><code>
Mixer fun() {
    int z;
    Mixer x;
    return x;
}

Mixer y{fun()};
        </code></pre>
        </div>
<!-- =================================================================================================== -->        
        <div id="copyElision20" class="step" data-x="5200" data-y="800" data-z="0">
        <img style="float:right" src=images/copyElision/fun_stack5.PNG>
        <pre class=left><code>
Mixer fun() {
    int z;
    Mixer x;
    return x;
}

Mixer y{fun()};
        </code></pre>
        </div>
<!-- =================================================================================================== -->        
        <div id="copyElision21" class="step" data-x="5200" data-y="1600" data-z="0">
        <p class=title>RVO in C++17</p>
        <pre><code><p style="text-align: left">
struct Factory {
  Factory(){};
  Factory(const Factory &) = delete;
  Factory(Factory &&) = delete;
};

Factory getFactory() { return Factory{}; }
    
<strong>error</strong>: use of deleted function
       'Factory::Factory(Factory&&)'
        </p>
        </code>
        </pre>
        <div class=notes>
        <p>- c11, c14 main problem - can't get rid of copy/move ctor
        <p>- copy elision might not take place
        <p>- prevents non-movable types from
        <p>- such as factories
        </p>
        In C++11 and C++14 the main problem is that, without guaranteed elision, you cannot get rid of the move and copy constructor,
        because elision might not take place. This prevents non-movable types from having functions that return by value,
        such as factories.
        </div>    
        </div>
<!-- =================================================================================================== -->            
        <div id="copyElision22" class="step" data-x="5200" data-y="2400" data-z="0">
        <p class=title>"Guaranteed copy elision through simplified value categories"</p>
        <br>
        <p class=left>- prvalue - initializer of object</p>
        <p class=left>- glvalue - location of object</p>
        <p class=left>- value returned from function, when init with temporary, is init directly
        <p class=left>- no copy/move ctor needed
        <div class=notes>
        <p>- name of proposal
        <p>- distinguish between prvalue and temp objects initialized by them
        <p>- g/p defined as ...
        <p>- prvalue initializes object directly
        <p>- as a consequence, init ...
        <p>- no copy, no move
        <p>- move/copy ctors not needed
        </p>
        The complete name of the proposal is ...
        To achieve guaranteed copy elision, the proposal suggest distinguishing between prvalue (pure rvalue) expressions
        and the temporary objects initialized by them. More specifically, a glvalue (generalized lvalue) is defined
        as the location of an object and a prvalue is defined as the initializer of the object.
        If a prvalue is used as the initializer of an object with the same type, it initializes it directly.
        As a consequence, initializing the return value of a function with a temporary causes the value to be initialized directly,
        without a copy or a move. This means that the copy or move constructor of the object no longer needs to be accessible.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="copyElision23" class="step" data-x="5200" data-y="3200" data-z="0">
        <p class=title>Actually...</p>
        <p class=left>- it's not copy elision anymore
        <p class=left>- no copy to elide
        <p class=left><strong>- deferred temporary materialization</strong></p>
            
        </div>
<!-- =================================================================================================== -->
<!--                                    Chapter II - Move                                         -->
<!-- =================================================================================================== -->
        <div id="Move1" class="step" data-x="7800" data-y="0" data-z="0">
        <p class=title>When copy elision not eligible...</p>
        <p>then create new object</p>
        <br><br>
        <p class=title2>copy or <strong>move</strong></p>
        <div class=notes>
        <p>- we just went through [...] but why?
        <p>- still keep in mind non compile?
        <p>- we remember that compiler error was [...]
        <p>- be patient, we're getting there
        <p>- when no copy elision, then create object
        <p>- move/copy - what criteria?
        </p>
        Ok, we've just went through copy elision criteria and examples but why? We still keep in mind our non compiling 
        examples from previous secion right? We remember that compiler error was that 
        it wanted to call converting move ctor but had only lvalue object so printed en error right? Be patient, we're getting there. 
        
        So on function return, when copy elision is not eligible, new object needs to be created. It can be created using
        move ctor or copy ctor. What are criteria that compiler uses to take this decision?
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move2" class="step" data-x="9100" data-y="0" data-z="0">
        <p class=title>Move or copy?</p>
        <pre class=left><code>
Mixer fun1() {
    // easy - rvalue so move ctor
    return Mixer{};
}



Mixer fun2() {
    // but here's lvalue...
    Mixer x;
    return x;
}
        </code></pre>
        <div class=notes>
        <p>- fun1()
        <p>- fun2()
        <p>- performance issue
        <p>- nice to have a mechanism that allowes move here
        <p>- actually there's one
        </p>
        lvalue so should be copy ctor but obviously it would be performance issue. So it would be nice 
        to have a mechanism that allowed to do move operation here. Actually there's one.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move3" class="step" data-x="10400" data-y="0" data-z="0">
        <p class=title>C++11* criteria for RVO with move</p>
        <br><br>
        <img src=images/rvoMove/cpp11_move_criteria.PNG>
        <div class=notes>
        <p>- highlited -> doit 
        <p>- tied closely with crit for c.e.
        <p>- only diff - can be used for fun param
        <p>- fun2() - move op
        <p>- compulsory, not as with c.e.
        </p>
        A lot of test but don't worry, highlited.
        Criteria for creation of new object with move op tied closely with criteria for copy elision, the only 
        difference is it can be used for fun param.
        In example fun2 works fine here.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move4" class="step" data-x="10400" data-y="800" data-z="10">
        <p class=title>So move instead of copy elision but criteria tied closely...</p>
        <br><br>
        <p class=left>- when -fno-elide-constructors</p>
        <p class=left>- when decision not to perform copy elision as it's not mandatory
        <p class=left>- when fun param
        <div class=notes>
        <p>- even if eligible for copy elision, might have decided, as prev section
        </p>
        So when can we use it when criteria for copy elision are met but copy elision is not performed?
        For sure when compiling with - fno-elide-constructors flag. But remember also that copy elision in cpp11 and cpp14
        is not required, so even when sth is eligible to copy elision, compiler engineers might have decided not to do so,
        as in example with exception in previous section.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move5" class="step" data-x="10400" data-y="1600" data-z="20">
        <p class=title>DR1579</p>
        <p style="font-size:25">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1579</p>
        <p style="font-size:25">2012-2014
        <p>
        <img src=images/rvoMove/DR1579.PNG>
        <div class=notes>
        <p>-
        </p>
        Similar situation to ours but with optional, but the same problem noticed - converting ctor can't be used
        withoud explicit std::move on return. Reported in 2012, resolved in 2014.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move6" class="step" data-x="10400" data-y="2400" data-z="300">
        <p class=title>DR1579 resolution</p>
        <img src=images/rvoMove/DR1579_resolution.PNG>
        <p class=left> wording in C++14
        <p class=left> added retrospectively to C++11 with C++14 standard publication
        <p>
        <div class=notes>
        <p>-
        </p> 
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move7" class="step" data-x="9100" data-y="2400" data-z="0" style="font-size:30">
        <pre class=left><code>
unique_ptr&lt<strong>MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>Mixer</strong>>();
    return <strong>mixer</strong>;
}       </code></pre>
        <p><strong>pre</strong> DR1579 compiler reasoning:
        <p class=left>- can I perform copy elision? No, types are different.
        <p class=left>- let's create new object.
        <p class=left>- can I treat object as rvalue and try to use move ctor for this?
        <p class=left>- no, criteria here are tied with copy elision.
        <p class=left>- ctor overload resolution
        <p class=left>- dammit, only move converting ctor available, error.
        <div class=notes>
        <p>-
        </p>
        Ok, so we can go back to our non compiling eamples.
        Reasoning of the old compiler was like this: can i perform copy elision? No, since types returned and to be 
        returned are different. Let's create new object. Can I treat object as rvalue and use move ctor for this?
        No, since criteria here is coupled with criteria for copy elision. So need to use copy ctor, which is deleted.
        Dammit, error...
        Exactly the same for example with const.
        
        Newer compiler follows new rules that are not so tightly coupled with copy elision criteria - 
        object of automatic storage doesn't have to be of the same type anymore.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move8" class="step" data-x="9100" data-y="1600" data-z="0" style="font-size:30">
        <pre class=left><code>
unique_ptr&lt<strong>const MixerInterface</strong>> create()
{
    auto mixer = make_unique&lt<strong>MixerInterface</strong>>();
    return mixer;
}       </code></pre>
        <p><strong>post</strong> DR1579 compiler reasoning:
        <p class=left>- can I perform copy elision? No, types are different.
        <p class=left>- let's create new object.
        <p class=left>- can I treat object as rvalue and try to use move ctor for this?
        <p class=left>- yes, it's an object with automatic storage duration, go ahead
        <p class=left>- ctor overload successful, converting move ctor chosen
        <div class=notes>
        <p>-
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move9" class="step" data-x="9100" data-y="800" data-z="0" style="font-size:30">
        <p style="font-size:40">So why class hierarchy compiled on old compiler?</p>
        <pre class=left><code>
<strong>MixerInterface</strong> create()
{
    <strong>Mixer</strong> x;
    return x;
}
        </code></pre>
        <div class=notes>
        <p>-
        </p>
        Ok so one can ask why this example didn't fail? We have similar situation, with different types returned and
        to be returned.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move10" class="step" data-x="7800" data-y="800" data-z="0">
        <p class=title>Return statement</p>
        <p class=left>evaluates the expression
        <p class=left>terminates current function
        <p class=left>and returns the result of the expression to the caller,
        <p class=left>after implicit conversion to the function return type. 
        <div class=notes>
        <p>- when we look at return statement description
        <p>- ...
        <p>- implicit converion is important for us
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move11" class="step" data-x="7800" data-y="1600" data-z="0" style="font-size:30">
        <pre class=left><code>
<strong>MixerInterface</strong> create()
{
    <strong>Mixer</strong> x;
    return x;
}       </code></pre>
        <p><strong>pre</strong> DR1579 compiler reasoning:
        <p class=left>- can I perform copy elision?
        <br>- no cause different types.
        <br>- evaluate expression.
        <br>- can I treat object as rvalue and try to use move ctor for this?
        <br>- no, since criteria are the same as for copy elision.
        <br>- so need to treat it as lvalue.
        <br>- implicit cast to return type
        <br>- ctor overload resolution - copy ctor
        <p>
        <p class=left>In unique_ptrs both decisions were also negative, but no implicit cast was available.
        <div class=notes>
        <p>- 
        </p>
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move12" class="step" data-x="7800" data-y="2400" data-z="0" style="font-size:30">
        <pre class=left><code>
<strong>MixerInterface</strong> create()
{
    <strong>Mixer</strong> x;
    return x;
}       </code></pre>
        <p><strong>post</strong> DR1579 compiler reasoning:
        <p class=left>- can I perform copy elision?
        <br>- no cause different types.
        <br>- evaluate expression.
        <br>- can I treat object as rvalue and try to use move ctor for this?
        <br><strong>- yes, it's an object with automatic storage duration, go ahead
        <br>- type of ctor arg is not rvalue ref to its param's type</strong>
        <br>- so need to treat as lvalue
        <br>- implicit cast to return type
        <br>- ctor overload resolution - copy ctor
        <div class=notes>
        <p>- newer comp reasons the same
        <p>- for decision whether use move ctor uses different from copy elision
        <p>- so tries to overload ctor with rval ref
        <p>- overload fails bc no converting ctor for base class present
        <p>- the rest of mechanism is the same
        </p>
        Newr compiler, with bug fixed reasons the same, but for decision whether to use move ctor doesn't use criteria
        for copy elision but tries to overload ctor with rvalue reference. Overload fails bc base class doesn't have 
        converting ctor with param of type of Mixer. The rest of mechanism is the same.
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move13" class="step" data-x="7800" data-y="3200" data-z="0">
        <p class=title>Back to class hierarchy example</p>
        <p>Why gcc 8.1+ uses move?</p>
        <pre class=left><code>
MixerInterface create()
{
    Mixer x;
    return x;
    // gcc 8.1+     - move ctor
    // gcc 8.0-     - copy ctor
    // clang 8.0.0  - copy ctor
    // c++ standard - copy ctor
}
        </code></pre>
        <div class=notes>
        <p>- last question to answer
        <p>- why ...
        <p>- copy is conformant to standard
        <p>- gcc engineers try to be clever here and are ahead
        <p>- there's a proposal suggesting to standardize this example
        </p>
        We have last question to answer - why in this example pre 8.0 gcc and all clang is performing a copy and gcc+ is doing move?
        Actually it's the copy that is conformant with standard. But gcc engineers try to be clever and are little bit ahead here,
        there's a proposal that suggests resolving move ctor in such case. 
        </div>
        </div>
<!-- =================================================================================================== -->
        <div id="Move14" class="step" data-x="9100" data-y="3200" data-z="0">
        </div>
<!-- =================================================================================================== -->
        <div id="Move15" class="step" data-x="10400" data-y="3200" data-z="0">
        </div>
<!-- =================================================================================================== -->
        <div id="Move16" class="step" data-x="10400" data-y="4000" data-z="0">
        </div>
        <div class="step" data-x="9100" data-y="4000" data-z="0">
        </div>
        <div class="step" data-x="7800" data-y="4000" data-z="0">
        </div>
        <div class="step" data-x="11700" data-y="0" data-z="0">asdasda</div>
        <div class="step" data-x="11700" data-y="800" data-z="0">
        </div>
        <div class="step" data-x="11700" data-y="1600" data-z="0">
        </div>
        <div class="step" data-x="11700" data-y="2400" data-z="0">
        </div>
        <div class="step" data-x="11700" data-y="3200" data-z="0">
        </div>
        <div class="step" data-x="11700" data-y="4000" data-z="0">
        asd
        </div>
        <!--
            <div id="slide2" class="step" data-x="1200" "data-y="0" data-z="0">
                <p>This Slide Moves From Right To Left</p>
            </div>

            <div id="slide3" class="step" data-x="2200" data-y="500">
                <p>This Slide Moves From Right To Left and Bottom To Top</p>
            </div>

            <div id="slide4" class="step" data-x="2200" data-y="-500">
                <p>This Slide Moves Top To Bottom</p>
            </div>

            <div id="slide5" class="step" data-x="3200" data-rotate="150">
                <p>This Slide Rotates Clockwise Around z-axis</p>
            </div>

            <div id="slide6" class="step" data-x="6200" data-scale='3'>
                <p>This Slide Scales 3 Times</p>
            </div>

            <div id="slide7" class="step" data-x="4200" data-y='1500' data-z='1500'>
                <p>Away</p>
            </div>

            <div id="slide8" class="step" data-x="4900" data-y='1500' data-z='100'>
                <p>Towards</p>
            </div>

            <div id="slide9" class="step" data-x="5600" data-y='1500' data-z='-1500'>
                <p>Futher Towards</p>
            </div>
 -->
        <!--
            <div id="slide10" class="step" data-x="2600" data-y='3000' data-scale='15'>
                <p>Visualization Slide Positions</p>
            </div>
 -->

    </div>

    <div class="fallback-message">
        <p>
            Your browser <b>doesn't support the features required</b> by
            impress.js, so you are presented with a simplified version of this
            presentation.
        </p>
        <p>
            For the best experience please use the latest <b>Chrome</b>, <b>Safari</b>
            or <b>Firefox</b> browser.
        </p>
    </div>

    <script type="text/javascript" src="js/impress.js"></script>
    <script type="text/javascript">impress().init();</script>
</body>
</html>


